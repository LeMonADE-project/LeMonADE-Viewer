/*--------------------------------------------------------------------------------
 _______________
|   /       \   | L   attice-based  | LeMonADE-Viewer:
|  /   ooo   \  | e   xtensible     | ----------------
| /  o\.|./o  \ | Mon te-Carlo      | An Open Source Visualization Tool for
|/  o\.\|/./o  \| A   lgorithm and  | for BFM-files generated by LeMonADE-software.
|  oo---0---oo  | D   evelopment    | See: https://github.com/LeMonADE-project/LeMonADE
|\  o/./|\.\o  /| E   nvironment    |
| \  o/.|.\o  / | -                 |
|  \   ooo   /  | Viewer            | Copyright (C) 2013-2015 by
|___\_______/___|                   | LeMonADE-Viewer Principal Developers (see AUTHORS)
----------------------------------------------------------------------------------

This file is part of LeMonADE-Viewer.

LeMonADE-Viewer is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE-Viewer is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE-Viewer.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#include <LeMonADE-Viewer/Camera.h>

#include <fstream>
#include <ostream>
#include <iostream>

Camera::Camera() {
  
  //Camera position
  CamPosition.setAllCoordinates(0.0f, 0.0f, 0.0f);

  //Linear Camera movement (left, right, up, down, in out)
  CamSpeedMovement.setAllCoordinates(0.0f, 0.0f, 0.0f);

  //Camera rotation angles
  CamAngleYaw = 0.0f;  // rotation in x-z-plane
  CamAnglePitch = 0.0f;  // rotation perpendicular to x-z-plane
  
  //Axis for camera rotation with angle theta
  camThetaRotAxisX = 1.0f;
  camThetaRotAxisZ = 0.0f;
  
  CamAngleYawSpeed = 0.0f;
  CamAnglePitchSpeed= 0.0f;

  movementSpeedFactor = 1.0f;
  
  //Is a key pressed for linear camera movement?
  holdingForwardI = false;	// key I = zoom in
  holdingBackwardO = false;	// key O = zoom out
  holdingUpW = false;		// key W = move up
  holdingDownS = false;		// key S = move down
  holdingLeftA = false;		// key A = move left
  holdingRightD = false;	// key D = move right
  
  //Is the mouse button pressed for camera rotation?
  holdingMouseButtonLeft = false;
  
  holdingForwardMouse = 0.0f;
  holdingBackwardMouse = 0.0f;
}

Camera::~Camera() {
  
}

/****************************/
//Get camera position

float Camera::getCamXPos() const {
  return CamPosition.getX();
}

float Camera::getCamYPos() const {
  return CamPosition.getY();
}

float Camera::getCamZPos() const {
  return CamPosition.getZ();
}

//Get rotation angles
float Camera::getCamAngleYaw() const {
  return CamAngleYaw;
}

float Camera::getCamAnglePitch() const {
  return CamAnglePitch;
}

//Get x- and z-component of the rotation axis for rotation angle theta 
float Camera::getCamThetaRotAxisX() const {
  return camThetaRotAxisX;
}

float Camera::getCamThetaRotAxisZ() const {
  return camThetaRotAxisZ;
}

//Get linear camera movement
float Camera::getCamXSpeed() const {
  return CamSpeedMovement.getX();
}

float Camera::getCamYSpeed() const {
  return CamSpeedMovement.getY();
}

float Camera::getCamZSpeed() const {
  return CamSpeedMovement.getZ();
}

float Camera::getMovementSpeedFactor() const {
  return movementSpeedFactor;
}

//Get the button-pressed-status for the "linear-movement" buttons
bool Camera::getHoldingForwardI() const {
  return holdingForwardI;
}

bool Camera::getHoldingBackwardO() const {
  return holdingBackwardO;
}

bool Camera::getHoldingUpW() const {
  return holdingUpW;
}

bool Camera::getHoldingDownS() const {
  return holdingDownS;
}

bool Camera::getHoldingLeftA() const {
  return holdingLeftA;
}

bool Camera::getHoldingRightD() const {
  return holdingRightD;
}

//Get the button-pressed-status for the mouse button (used for rotation)
bool Camera::getHoldingMouseButtonLeft() const {
  return holdingMouseButtonLeft;
}

//Get the status for mouse-wheel-zooming
float Camera::getHoldingForwardMouse() const {
  return holdingForwardMouse;
}

float Camera::getHoldingBackwardMouse() const {
  return holdingBackwardMouse;
}

/****************************/
//Set camera position
void Camera::setCamXPos(float camXPos) {
	CamPosition.setX(camXPos);
}

void Camera::setCamYPos(float camYPos) {
	CamPosition.setY(camYPos);
}

void Camera::setCamZPos(float camZPos) {
	CamPosition.setZ(camZPos);
}


//Set rotation angles
void Camera::setCamAngleYaw(float camAngleYaw) {
	CamAngleYaw = camAngleYaw;
}

//Set rotation angles
void Camera::setCamAngleYawSpeed(float camAngleYawSpeed) {
	CamAngleYawSpeed = camAngleYawSpeed;
}

void Camera::setCamAnglePitch(float camAnglePitch) {
	CamAnglePitch = camAnglePitch;
}

void Camera::setCamAnglePitchSpeed(float camAnglePitchSpeed) {
	CamAnglePitchSpeed = camAnglePitchSpeed;
}

//Set x- and z-component of the rotation axis for rotation angle theta 
void Camera::setCamThetaRotAxisX(float camThetaRotAxisXParam) {
  this->camThetaRotAxisX = camThetaRotAxisXParam;
}

void Camera::setCamThetaRotAxisZ(float camThetaRotAxisZParam) {
  this->camThetaRotAxisZ = camThetaRotAxisZParam;
}

void Camera::setCamXSpeed(float camXSpeed) {
  CamSpeedMovement.setX(camXSpeed);
}

void Camera::setCamYSpeed(float camYSpeed) {
CamSpeedMovement.setY(camYSpeed);
}

void Camera::setCamZSpeed(float camZSpeed) {
	CamSpeedMovement.setZ(camZSpeed);
}

void Camera::setMovementSpeedFactor(float movementSpeedFactorParam) {
  this->movementSpeedFactor = movementSpeedFactorParam;
}

//Set the button-pressed-status for the "linear-movement" buttons
void Camera::setHoldingForwardI(bool holdingForwardIParam) {
  this->holdingForwardI = holdingForwardIParam;
}

void Camera::setHoldingBackwardO(bool holdingBackwardOParam) {
  this->holdingBackwardO = holdingBackwardOParam;
}

void Camera::setHoldingUpW(bool holdingUpWParam) {
  this->holdingUpW = holdingUpWParam;
}

void Camera::setHoldingDownS(bool holdingDownSParam) {
  this->holdingDownS = holdingDownSParam;
}

void Camera::setHoldingLeftA(bool holdingLeftAParam) {
  this->holdingLeftA = holdingLeftAParam;
}

void Camera::setHoldingRightD(bool holdingRightDParam) {
  this->holdingRightD = holdingRightDParam;
}

//Set the button-pressed-status for the mouse button (used for rotation)
void Camera::setHoldingMouseButtonLeft(bool holdingMouseButtonLeftParam) {
  this->holdingMouseButtonLeft = holdingMouseButtonLeftParam;
}

void Camera::setHoldingForwardMouse (float holdingForwardMouseParam) {
  this->holdingForwardMouse = holdingForwardMouseParam;
}

void Camera::setHoldingBackwardMouse (float holdingBackwardMouseParam) {
  this->holdingBackwardMouse = holdingBackwardMouseParam;
}

/****************************/

//Funktion to calculate the radian values of rotation angles
float Camera::toRads(const float theAngleinDegrees) {
  float pi = atan(1)*4;
  return theAngleinDegrees * pi / 180.0f;
}

/****************************/

//Funktion to calculate the linear camera movement
void Camera::calculateCameraMovement() {
  
  float camMovementXComponent = 0.0f;
  float camMovementYComponent = 0.0f;
  float camMovementZComponent = 0.0f;
  
  //If one of the buttons is pressed, the camera gets moved in the appropriate 
  //direction with constant speed. This means, a position difference is calculated 
  //(can be either + or - movementSpeedFactor).
  if (holdingForwardI == true) {
    camMovementZComponent = -movementSpeedFactor;
  }
  
  if (holdingBackwardO == true) {
   camMovementZComponent = movementSpeedFactor;
  }

  if (holdingUpW == true) {
    camMovementYComponent = movementSpeedFactor;
  }

  if (holdingDownS == true) {
    camMovementYComponent = -movementSpeedFactor;
  }
  

  if (holdingLeftA == true) {
    camMovementXComponent = -movementSpeedFactor;
  }
  
  if (holdingRightD == true) {
    camMovementXComponent = movementSpeedFactor;
  }


  //The absolute position difference/speed of the camera 
  CamSpeedMovement.setAllCoordinates(camMovementXComponent, camMovementYComponent, camMovementZComponent);
  
  //Set a maximum for the camera position difference/speed 
  /*if (camXSpeed > movementSpeedFactor) {
    camXSpeed = movementSpeedFactor;
  }
  
  if (camXSpeed < -movementSpeedFactor) {
    camXSpeed = -movementSpeedFactor;
  }
  
  if (camYSpeed > movementSpeedFactor) {
    camYSpeed = movementSpeedFactor;
  }
  
  if (camYSpeed < -movementSpeedFactor) {
    camYSpeed = -movementSpeedFactor;
  }
  
  if (camZSpeed > movementSpeedFactor) {
    camZSpeed = movementSpeedFactor;
  }
  
  if (camZSpeed < -movementSpeedFactor) {
    camZSpeed = -movementSpeedFactor;
  } 
  */
}


//Funktion to calculate the rotation angles and rotation axis for rotation with angle theta,
//when the mouse button is pressed and the mouse is moved
void Camera::handleMouseMove(int mouseX, int mouseY, int boxX, int boxY, int boxZ) {
  float horizMouseSensitivity = 10.0f;
  float vertMouseSensitivity = 10.0f;
  
  //movement angle phi in x-z-plane when mouse is moved horizontally
  float phiMovement = (mouseX * 180.0f) / boxX; //yaw
  //movement angle theta perpendicular to x-z-plane when mouse is moved vertically
  float thetaMovement = - (mouseY * 180.0f) / boxY; //pitch
  


  CamAngleYaw += phiMovement / horizMouseSensitivity;
  CamAnglePitch += thetaMovement / vertMouseSensitivity;


  CamAngleYawSpeed = phiMovement / horizMouseSensitivity /5.f;
  CamAnglePitchSpeed = thetaMovement / vertMouseSensitivity  /5.f;


  float camPhiRads = toRads(CamAngleYaw);
  float camThetaRads = toRads(CamAnglePitch);
  
  //Calculation of the rotation axis for angle theta
  //This is needed to ensure that displayed simulation box is always rotated in the same direction when 
  //the mouse is moved e.g. upwards
  camThetaRotAxisX = cos(camPhiRads);
  camThetaRotAxisZ = sin(camPhiRads);
  
  
  /*glm::vec3 front;
      front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
      front.y = sin(glm::radians(pitch));
      front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
      cameraFront = glm::normalize(front);
*/
}

//Funktion to set the new camera position after a linear movement
void Camera::moveCamera() {

	CamPosition += CamSpeedMovement;

	CamPosition.setY( CamPosition.getY() -holdingForwardMouse);
	CamPosition.setY( CamPosition.getY() +holdingBackwardMouse);
  
  
  holdingForwardMouse = 0.0f;
  holdingBackwardMouse = 0.0f;
  
  CamAngleYaw += CamAngleYawSpeed;
  CamAnglePitch += CamAnglePitchSpeed;

  float camPhiRads = toRads(CamAngleYaw);
  camThetaRotAxisX = cos(camPhiRads);
  camThetaRotAxisZ = sin(camPhiRads);


}
