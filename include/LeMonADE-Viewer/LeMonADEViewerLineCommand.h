/*--------------------------------------------------------------------------------
 _______________
|   /       \   | L   attice-based  | LeMonADE-Viewer:
|  /   ooo   \  | e   xtensible     | ----------------
| /  o\.|./o  \ | Mon te-Carlo      | An Open Source Visualization Tool for
|/  o\.\|/./o  \| A   lgorithm and  | for BFM-files generated by LeMonADE-software.
|  oo---0---oo  | D   evelopment    | See: https://github.com/LeMonADE-project/LeMonADE
|\  o/./|\.\o  /| E   nvironment    |
| \  o/.|.\o  / | -                 |
|  \   ooo   /  | Viewer            | Copyright (C) 2013-2015 by
|___\_______/___|                   | LeMonADE-Viewer Principal Developers (see AUTHORS)
----------------------------------------------------------------------------------

This file is part of LeMonADE-Viewer.

LeMonADE-Viewer is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE-Viewer is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE-Viewer.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#pragma once

#include <string>
#include <sstream>
#include <algorithm>    // std::find_if
#include <iostream>
#include <string>
#include <map>
#include <utility>
#include <functional>
#include <queue>
#include <vector>
#include <math.h>

#include <LeMonADE/utility/RandomNumberGenerators.h>

template<class IngredientsType, class MoleculesType>
class LineCommandBase
{
public:

	virtual ~LineCommandBase(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& str)=0;

	std::vector<std::string> tokenize1Parameter(const std::string& str,
			char delim) {
		std::vector<std::string> tokens;
		std::stringstream mySstream(str);
		std::string temp;

		while (getline(mySstream, temp, delim)) {
			tokens.push_back(temp);
		}

		return tokens;

	}

	std::vector<std::string> tokenize2Parameter(const std::string& str,	char delim1, char delim2) {
		std::vector<std::string> tokens;
		std::stringstream mySstream(str);
		std::string temp;

		while (getline(mySstream, temp, delim1)) {

			if(temp.size() != 0)
			{
				std::stringstream mySstream2(temp);
				std::string temp2;
				while (getline(mySstream2, temp2, delim2)) {
					//printf("%s \n", temp2.c_str());
					if(temp2.size() != 0)
						tokens.push_back(temp2);
				}
			}

		}

		return tokens;

	}

	std::vector<std::string> tokenize3Parameter(const std::string& str,
			char delim1, char delim2, char delim3) {
		std::vector<std::string> tokens;
		std::stringstream mySstream(str);
		std::string temp;

		while (getline(mySstream, temp, delim1)) {
			std::stringstream mySstream2(temp);
			std::string temp2;
			while (getline(mySstream2, temp2, delim2)) {
				std::stringstream mySstream3(temp2);
				std::string temp3;
				while (getline(mySstream3, temp3, delim3)) {

					//printf("%s \n", temp2.c_str());
					tokens.push_back(temp3);
				}
			}

		}

		return tokens;

	}
};

// handles
// !setColor:idx1-idx2=(r,g,b)
// !setColor:all=(r,g,b)
// !setColor:BG=(r,g,b)

template<class IngredientsType, class MoleculesType>
class CommandSetColor : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColor(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColor");

		//get monomer information
		std::vector<std::string> mono = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((mono.size() ==0) || (mono.size() > 2) )
			return std::string("error in command !setColor:monomerindex");

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColor:color");


		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColor:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColor:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColor:blue color");
		}

		//color all monomers
		if(mono.size()==1 && (!mono[0].compare("all")))
		{
			//std::cout << "color all monomers"<< std::endl;

			for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);

			return std::string("apply color to all monomers");
		}

		//color the background
		if(mono.size()==1 && (!mono[0].compare("BG")))
		{
			//std::cout << "color BG"<< std::endl;
			//set background color
			ingredients.setBGcolor(red, green, blue);

			return std::string("apply color to BG");
		}

		// label monomer in range
		if(mono.size()==2)
		{

			uint32_t mono1 = 0;
			uint32_t mono2 = 0;

			std::istringstream ss1(mono[0]);
			ss1 >> mono1;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:1.st monomer index");
			}

			if(mono1 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 1.st monomer index");
			}

			std::istringstream ss2(mono[1]);
			ss2 >> mono2;

			if(mono2 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 2.nd monomer index");
			}
			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:2.st monomer index");
			}

			if(mono1 < mono2)
			{
				for(uint32_t i = mono1; i <= mono2; i++)
					ingredients.modifyMolecules()[i].setColor( red ,green , blue);
			}
			else
			{for(uint32_t i = mono2; i <= mono1; i++)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);
			}

			return std::string("apply color monomers");
		}
		return std::string("could not color anything");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorAttributes : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorAttributes(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorAttributes " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorAttributes");

		int32_t attribute=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> attribute;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setColorAttributes: attribute");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorAttributes:color");

		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorAttributes:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorAttributes:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorAttributes:blue color");
		}

		//color all monomers
		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].getAttributeTag() == attribute)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);

		return std::string("apply color to all monomers with attribute");
	}
};


template<class IngredientsType, class MoleculesType>
class CommandSetColorLinks : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorLinks(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorLinks " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorLinks");

		int32_t numLinks=0;

		std::istringstream ccLinks(vex[1]);
		ccLinks >> numLinks;

		//numLinks is wrong
		if(ccLinks.fail()){
			return std::string("error in command !setColorLinks: numLinks");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorLinks:color");

		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorLinks:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorLinks:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorLinks:blue color");
		}

		//color all monomers


		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
		{
			if(ingredients.modifyMolecules().getNumLinks(i) == numLinks)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);
		}

		return std::string("apply color to all monomers with numLinks");
	}
};




template<class IngredientsType, class MoleculesType>
class CommandSetColorTopology : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorTopology(){};
    
    typedef uint32_t NodeIdx;
    typedef std::map<NodeIdx, int> Nodelist;
    typedef std::map<NodeIdx, Nodelist> Graph;
    //typedef std::pair<NodeIdx, Nodelist> Node;
    typedef std::pair<int, NodeIdx> Edge; //! (tentative distance, idxNode)
    typedef std::vector<NodeIdx> NodeVector;

    void dijkstra(Graph &graph, NodeIdx source, Nodelist &distance);

    void findCentersOfTree(Graph &graph,  Nodelist degreeNodes, NodeVector &centerNodes);

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorLinks " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorTopology");

        //get color information
		std::vector<std::string> colorStart = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[1], '(', ',' , ')');
		
        if(colorStart.size() !=3 )
			return std::string("error in command !setColorTopology:color");

		float redStart = 0.0f;
		float greenStart = 0.0f;
		float blueStart = 0.0f;

		std::istringstream ccRedStart(colorStart[0]);
		ccRedStart >> redStart;

		//first mono index is wrong
		if(ccRedStart.fail()){
			return std::string("error in command !setColorTopology:red color Start");
		}

		std::istringstream ccGreenStart(colorStart[1]);
		ccGreenStart >> greenStart;

		//first mono index is wrong
		if(ccGreenStart.fail()){
			return std::string("error in command !setColorTopology:green color Start");
		}

		std::istringstream ccBlueStart(colorStart[2]);
		ccBlueStart >> blueStart;

		//first mono index is wrong
		if(ccBlueStart.fail()){
			return std::string("error in command !setColorTopology:blue color Start");
		}
		

		//get color information
		std::vector<std::string> colorEnd = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(colorEnd.size() !=3 )
			return std::string("error in command !setColorTopology:color");

		float redEnd = 0.0f;
		float greenEnd = 0.0f;
		float blueEnd = 0.0f;

		std::istringstream ccRedEnd(colorEnd[0]);
		ccRedEnd >> redEnd;

		//first mono index is wrong
		if(ccRedEnd.fail()){
			return std::string("error in command !setColorTopology:red color End");
		}

		std::istringstream ccGreenEnd(colorEnd[1]);
		ccGreenEnd >> greenEnd;

		//first mono index is wrong
		if(ccGreenEnd.fail()){
			return std::string("error in command !setColorTopology:green color End");
		}

		std::istringstream ccBlueEnd(colorEnd[2]);
		ccBlueEnd >> blueEnd;

		//first mono index is wrong
		if(ccBlueEnd.fail()){
			return std::string("error in command !setColorTopology:blue color End");
		}

		//color all monomers


		/*for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
		{
			if(ingredients.modifyMolecules().getNumLinks(i) == numLinks)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);
		}*/
		
		Graph treeGraph;


	Nodelist  degreeNode; // Degree of node

	for (int k= 0; k < ingredients.getMolecules().size(); k++)
			{
				for (int l = 0; l < ingredients.getMolecules().getNumLinks(k); l++)
				{
						// connect from idxAA to idxBB with value ZZ
						// all (symmetric) connections
						treeGraph[k][ingredients.getMolecules().getNeighborIdx(k, l)]=1;

				}
				// fill with degree of nodes
				degreeNode[k]=ingredients.getMolecules().getNumLinks(k);
			}


	//finding the center of the tree (either one or two)
	NodeVector centerNodes;
	findCentersOfTree(treeGraph, degreeNode, centerNodes);

	//calculate the topological distance of center to all nodes and fill histogram
	NodeVector::iterator itv;
	for(itv=centerNodes.begin(); itv!=centerNodes.end(); ++itv){

		

	        NodeIdx startNode = (*itv);
	        std::cout << std::endl << "startNode: " << startNode << std::endl;

            // idx -> distance from center
	        Nodelist topo_distance;
	        dijkstra(treeGraph, startNode, topo_distance);

	        std::cout << "startNode -> node => distance" <<std::endl;
            
            int maxTopologicalDistance = 0;

	       	  Nodelist::iterator it;
	       	  for(it=topo_distance.begin(); it!=topo_distance.end(); ++it){

	       		 // std::cout<< startNode << " -> " << it->first << "  => "<<it->second<<std::endl;

                  //find the maximum topological distance from the tree center
                  if(maxTopologicalDistance < it->second)
                      maxTopologicalDistance=it->second;
              }
              std::cout<< startNode << " -> max topological distance " << maxTopologicalDistance <<std::endl;
              
              //color the structure
              for(it=topo_distance.begin(); it!=topo_distance.end(); ++it){

	       		//  std::cout<< startNode << " -> " << it->first << "  => "<<it->second<<std::endl;

                  // red part
                  double redFraction = redStart + (redEnd-redStart)*it->second/(1.0*maxTopologicalDistance);
                  
                  // green part
                  double greenFraction = greenStart + (greenEnd-greenStart)*it->second/(1.0*maxTopologicalDistance);
                  
                  // blue part
                  double blueFraction = blueStart + (blueEnd-blueStart)*it->second/(1.0*maxTopologicalDistance);
                  
                  
                  ingredients.modifyMolecules()[it->first].setColor( redFraction ,greenFraction , blueFraction);
              }
    
	       	  
	      }
		

		return std::string("apply color to all monomers with numTopology");
	}
};

template<class IngredientsType, class MoleculesType>
void CommandSetColorTopology<IngredientsType, MoleculesType>::findCentersOfTree(Graph &graph, Nodelist degreeNodes, NodeVector &centerNodes){

	std::queue <NodeIdx> queueLeaves; // Queue for algorithm holding (reduced) leaves
	std::queue <NodeIdx> queueNextLeaves; // Queue for algorithm holding next (reduced) leaves
	std::queue <NodeIdx> tmpOldLeaves; // Queue for algorithm holding (reduced) leaves

	// Fill and start from leaves

	Nodelist::iterator it;
	for(it=degreeNodes.begin(); it!=degreeNodes.end(); ++it)
	{
	        int degreeOfNode = it->second;
	        NodeIdx labelNode = it->first;

	        if (degreeOfNode == 1)
	        {
	        	queueLeaves.push(labelNode);
	        }
	}

	NodeIdx Seperator = -1;

	queueLeaves.push(Seperator);

	//  while ( (queueLeaves.front()!=Seperator)||(queueLeaves.size() > 2) ) {
	while ( (queueLeaves.size() > 0) ) {
		  NodeIdx node = queueLeaves.front();
		  queueLeaves.pop();

		  if( node == Seperator)
		  {
			  if(queueNextLeaves.empty())
				  break;

			 // std::cout << "next iteration: " << node << std::endl;
			  tmpOldLeaves = queueNextLeaves;
			  queueLeaves = queueNextLeaves;

			  if(queueNextLeaves.size() >0)
				  queueLeaves.push(Seperator);

			  queueNextLeaves=std::queue <NodeIdx>();

			  continue;
		  }


	 	      int dN_old = degreeNodes[node];

	 	      degreeNodes[node]--;

	 	     // new subgraph of all neighbors
	 	     Nodelist tempgraph=graph[node];

	 	     // connected nodes

	 	    // std::cout << "connected nodes from: " << node << std::endl;

	 	     Nodelist::iterator it;
	 	     for(it=tempgraph.begin(); it!=tempgraph.end(); ++it){

	 	    //	std::cout << it->first << " with degree: " << degreeNodes[it->first];

	 	    	 if(degreeNodes[it->first] > 0)
	 	    	 {
	 	    		degreeNodes[it->first]--;

	 	    	//	std::cout << " reduced to degree: " << degreeNodes[it->first];
	 	    	 }

	 	    	 if(degreeNodes[it->first] == 1)
	 	    	 {
	 	    		//queueLeaves.push(it->first);
	 	    		queueNextLeaves.push(it->first);

	 	    	//	std::cout << " added to queue the idx: " << (it->first);
	 	    	 }

	 	    	//std::cout << std::endl;
	 	     }


	 	  }

	std::cout << "center queue contains: ";
		  while (!tmpOldLeaves.empty())
		  {
			  centerNodes.push_back(tmpOldLeaves.front());
			  std::cout << ' ' <<  tmpOldLeaves.front();
			  tmpOldLeaves.pop();
		  }
		  std::cout << '\n';
}

template<class IngredientsType, class MoleculesType>
void CommandSetColorTopology<IngredientsType, MoleculesType>::dijkstra(Graph &graph, NodeIdx source, Nodelist &distance){

	distance.clear(); //! clear all tentative distance information

	//! list of all nodes to be visit and addressed already with least distance on top
  std::priority_queue<Edge, std::vector<Edge>, std::greater<Edge> > queueNode;

  // starting node with tentative distance=0, starting node = source
  queueNode.push( Edge(0, source) );

  while(!queueNode.empty()){

	  //get the element with least tentative distance
    Edge tmped=queueNode.top();

    // access the node index
    NodeIdx tmpnl=tmped.second;

    // removes the top element
    queueNode.pop();

    // if the node never visited before
    if(distance.count(tmpnl)==0){

    	// tentative distance to the recent node
      int dist=tmped.first;

      // set the tentative distance to the node
      distance[tmpnl]=dist;

      // new subgraph of all neighbors
      Nodelist tempgraph=graph[tmpnl];

      Nodelist::iterator it;
      for(it=tempgraph.begin(); it!=tempgraph.end(); ++it){
        int distint=it->second;
        NodeIdx distlabel=it->first;
        queueNode.push(Edge(dist+distint, distlabel));
      }

    }
  }

}

template<class IngredientsType, class MoleculesType>
class CommandSetVisible : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisible(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisible " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisible");

		//get monomer information
		std::vector<std::string> mono = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((mono.size() ==0) || (mono.size() > 2) )
			return std::string("error in command !setVisible: monomer index");

		//get visibility information
		int visible =0;

		std::istringstream ccVisible(vex[2]);
		ccVisible >> visible;

		//first mono index is wrong
		if(ccVisible.fail()){
			return std::string("error in command !setVisible: visibility");
		}

		//color all monomers
		if(mono.size()==1 && (!mono[0].compare("all")))
		{
			std::cout << "set visible all monomers"<< std::endl;

			for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
				ingredients.modifyMolecules()[i].setVisible(bool(visible));

			return std::string("set visibility to all monomers");
		}

		// label monomer in range
		if(mono.size()==2)
		{
			uint32_t mono1 = 0;
			uint32_t mono2 = 0;

			std::istringstream ss1(mono[0]);
			ss1 >> mono1;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:1.st monomer index");
			}

			if(mono1 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 1.st monomer index");
			}

			std::istringstream ss2(mono[1]);
			ss2 >> mono2;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor: 2.st monomer index");
			}

			if(mono2 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 2.nd monomer index");
			}

			if(mono1 < mono2)
			{
				for(uint32_t i = mono1; i <= mono2; i++)
					ingredients.modifyMolecules()[i].setVisible(bool(visible));
			}
			else
			{for(uint32_t i = mono2; i <= mono1; i++)
				ingredients.modifyMolecules()[i].setVisible(bool(visible));
			}

			return std::string("apply visibility to monomers");
		}
		return std::string("could not set visibility to monomers");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetVisibleAttributes : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisibleAttributes(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisibleAttributes " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisibleAttributes");

		int32_t attribute=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> attribute;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setColorAttributes: attribute");
		}

		//get visibility information
		int visible =0;

		std::istringstream ccVisible(vex[2]);
		ccVisible >> visible;

		if(ccVisible.fail()){
			return std::string("error in command !setVisibleAttributes: Visibility");
		}



		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].getAttributeTag() == attribute)
				ingredients.modifyMolecules()[i].setVisible( (bool(visible)));

		return std::string("apply visiblility to all monomers with attribute");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetVisibleLinks : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisibleLinks(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisibleLinks " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisibleLinks");

		int32_t numLinks=0;

		std::istringstream ccLinks(vex[1]);
		ccLinks >> numLinks;

		//attribute is wrong
		if(ccLinks.fail()){
			return std::string("error in command !setColorLinks: numLinks");
		}

		//get visibility information
		int visible =0;

		std::istringstream ccVisible(vex[2]);
		ccVisible >> visible;

		if(ccVisible.fail()){
			return std::string("error in command !setVisibleLinks: Visibility");
		}

		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules().getNumLinks(i) == numLinks)
				ingredients.modifyMolecules()[i].setVisible( (bool(visible)));

		return std::string("apply visiblility to all monomers with attribute");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorVisibility : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorVisibility(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorVisibility " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorVisibility");

		int32_t Visibility=0;

		std::istringstream ccVis(vex[1]);
		ccVis >> Visibility;

		//attribute is wrong
		if(ccVis.fail()){
			return std::string("error in command !setColorVisibility: Visibility");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorVisibility: Color");


		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorVisibility:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorVisibility:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorVisibility:blue color");
		}


		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].isVisible() == (bool(Visibility)))
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);

		return std::string("apply color to all (in)visible monomers ");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetVisibleGroups : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisibleGroups(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisibleGroups " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 4 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisibleGroups");

		//get monomer information
		std::vector<std::string> Groups = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((Groups.size() != 2) )
			return std::string("error in command !setVisible: monomer index");

		uint32_t group1 = 0;
		uint32_t group2 = 0;

		std::istringstream ss1(Groups[0]);
		ss1 >> group1;

		//first mono index is wrong
		if(ss1.fail()){
			return std::string("error in command !setColor:1.st group index");
		}

		if((group1 < 0) || (group1 >= molecules_type.size()))
		{
			return std::string("error in command !setColor: out-of-range 1.st group index");
		}

		std::istringstream ss2(Groups[1]);
		ss2 >> group2;

		//first mono index is wrong
		if(ss1.fail()){
			return std::string("error in command !setColor: 2.st group index");
		}

		if((group2 < 0) || (group2 >= molecules_type.size()))
		{
			return std::string("error in command !setColor: out-of-range 2.nd monomer index");
		}

		//get visibility information
		int visible =0;

		std::istringstream ccGroup(vex[2]);
		ccGroup >> visible;

		if(ccGroup.fail()){
			return std::string("error in command !setVisibleGroups: Visibility");
		}



		if(group1 < group2)
		{
			for(uint32_t i = group1; i <= group2; i++)
				for(size_t m=0; m< molecules_type[i].size(); ++m)
					ingredients.modifyMolecules()[molecules_type[i].trueIndex(m)].setVisible( (bool(visible)));


		}
		else
		{
			for(uint32_t i = group2; i <= group1; i++)
				for(size_t m=0; m< molecules_type[i].size(); ++m)
					ingredients.modifyMolecules()[molecules_type[i].trueIndex(m)].setVisible( (bool(visible)));

		}

		return std::string("visible color to all monomers within Groups");

	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorGroups : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorGroups(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorGroups " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorGroups");

		int32_t group=0;

		std::istringstream ccGroup(vex[1]);
		ccGroup >> group;

		//Group is wrong
		if(ccGroup.fail()){
			return std::string("error in command !setColorGroups: Groups");
		}

		if((group < 0) || (group >= molecules_type.size()))
		{
			return std::string("error in command !setColorGroups: Groups exceed range");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorGroups:color");


		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorGroups:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorGroups:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorGroups:blue color");
		}


		for(size_t m=0; m< molecules_type[group].size(); ++m){
			ingredients.modifyMolecules()[molecules_type[group].trueIndex(m)].setColor( red ,green , blue);

		}

		return std::string("apply color to all monomers within Groups");

	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorGroupsRandom : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorGroupsRandom(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorGroupsRandom " << std::endl;

		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 1 tokens
		if(vex.size() !=1 )
			return std::string("error in command !setColorGroups");

		RandomNumberGenerators RNG;

		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		//std::cout << "color all monomers whithin group"<< std::endl;
		for(size_t n=0; n< molecules_type.size(); ++n){

			red = RNG.r250_drand();
			green = RNG.r250_drand();
			blue = RNG.r250_drand();

			for(size_t m=0; m< molecules_type[n].size(); ++m){
				ingredients.modifyMolecules()[molecules_type[n].trueIndex(m)].setColor( red ,green , blue);

			}
		}
		return std::string("apply color to all monomers within Groups");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetRadius : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadius(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::cout << "!SetRadius in CommandSetRadius " << std::endl;

		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setRadius");

		//get monomer information
		std::vector<std::string> mono = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((mono.size() ==0) || (mono.size() > 2) )
			return std::string("error in command !setRadius:monomerindex");

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadiusr:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}

		//color all monomers
		if(mono.size()==1 && (!mono[0].compare("all")))
		{
			std::cout << "color all monomers"<< std::endl;

			for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
				ingredients.modifyMolecules()[i].setRadius( radius);

			return std::string("apply radius to all monomers");
		}

		// label monomer in range
		if(mono.size()==2)
		{
			//uint32_t mono1 = atoi(mono[0].c_str());
			//uint32_t mono2 = atoi(mono[1].c_str());

			uint32_t mono1 = 0;
			uint32_t mono2 = 0;

			std::istringstream ss1(mono[0]);
			ss1 >> mono1;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:1.st monomer index");
			}

			if(mono1 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 1.st monomer index");
			}

			std::istringstream ss2(mono[1]);
			ss2 >> mono2;

			if(mono2 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 2.nd monomer index");
			}
			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:2.st monomer index");
			}


			if(mono1 < mono2)
			{
				for(uint32_t i = mono1; i <= mono2; i++)
					ingredients.modifyMolecules()[i].setRadius( radius);
			}
			else
			{for(uint32_t i = mono2; i <= mono1; i++)
				ingredients.modifyMolecules()[i].setRadius( radius);
			}

			return std::string("apply radius monomers");
		}
		return std::string("could not change radius monomers");
	}
};


template<class IngredientsType, class MoleculesType>
class CommandSetRadiusAttributes : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadiusAttributes(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetRadius in CommandSetRadiusAttributes " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorAttributes");

		int32_t attribute=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> attribute;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setColorAttributes: attribute");
		}

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadius:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}

		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].getAttributeTag() == attribute)
				ingredients.modifyMolecules()[i].setRadius( radius);

		return std::string("apply radius to all monomers with attribute");

	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetRadiusLinks : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadiusLinks(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetRadiusLinks " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setRadiusLinks");

		int32_t numLinks=0;

		std::istringstream ccLinks(vex[1]);
		ccLinks >> numLinks;

		//numLinks is wrong
		if(ccLinks.fail()){
			return std::string("error in command !setRadiusLinks: numLinks");
		}

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadius:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}


		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules().getNumLinks(i) == numLinks)
				ingredients.modifyMolecules()[i].setRadius( radius);

		return std::string("apply radius to all monomers with numLinks");
	}
};


template<class IngredientsType, class MoleculesType>
class CommandSetRadiusGroups : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadiusGroups(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetRadiusGroups " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setRadiusGroups");

		int32_t group=0;

		//color all monomers

		std::istringstream ccGroup(vex[1]);
		ccGroup >> group;

		//Group is wrong
		if(ccGroup.fail()){
			return std::string("error in command !setRadiusGroups: Groups");
		}

		if((group < 0) || (group >= molecules_type.size()))
		{
			return std::string("error in command !setColorGroups: Groups exceed range");
		}

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadius:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}


		for(size_t m=0; m< molecules_type[group].size(); ++m){
			ingredients.modifyMolecules()[molecules_type[group].trueIndex(m)].setRadius( radius);

		}

		return std::string("apply color to all monomers within Groups");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandGetHelp : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandGetHelp(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::cout << "!help with known commands" << std::endl;

		return std::string("known commands:\n"
				"!setColor:idx1-idx2=(r,g,b)\n"
				"!setColor:all=(r,g,b)\n"
                "!setColor:BG=(r,g,b)\n"
				"!setColorAttributes:att=(r,g,b)\n"
				"!setColorLinks:numLinks=(r,g,b)\n"
				"!setColorVisibility:vis=(r,g,b)\n"
				"!setColorGroups:idxGroup=(r,g,b)\n"
				"!setColorGroupsRandom\n"
                "!setColorTopology:(rS,gS,bS)=(rE,gE,bE)\n"
				"!setVisible:idx1-idx2=vis\n"
				"!setVisible:all=vis\n"
				"!setVisibleAttributes:att=vis\n"
				"!setVisibleLinks:numLinks=vis\n"
				"!setVisibleGroups:idxG1-idxG2=vis\n"
				"!setRadius:idx1-idx2=radius\n"
				"!setRadius:all=radius\n"
				"!setRadiusAttributes:att=radius\n"
				"!setRadiusLinks:numLinks=radius\n"
				"!setRadiusGroups:idxGroup=radius\n");
	}
};
