/*--------------------------------------------------------------------------------
 _______________
|   /       \   | L   attice-based  | LeMonADE-Viewer:
|  /   ooo   \  | e   xtensible     | ----------------
| /  o\.|./o  \ | Mon te-Carlo      | An Open Source Visualization Tool for
|/  o\.\|/./o  \| A   lgorithm and  | for BFM-files generated by LeMonADE-software.
|  oo---0---oo  | D   evelopment    | See: https://github.com/LeMonADE-project/LeMonADE
|\  o/./|\.\o  /| E   nvironment    |
| \  o/.|.\o  / | -                 |
|  \   ooo   /  | Viewer            | Copyright (C) 2013-2015 by
|___\_______/___|                   | LeMonADE-Viewer Principal Developers (see AUTHORS)
----------------------------------------------------------------------------------

This file is part of LeMonADE-Viewer.

LeMonADE-Viewer is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE-Viewer is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE-Viewer.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#ifndef LEMONADE_VIEWER_OPENGL_H
#define LEMONADE_VIEWER_OPENGL_H

#include <FL/Fl.H>
#include <FL/Fl_Gl_Window.H>
#include <FL/gl.h>

#include <vector>

//#include <png.h> //export library for screenshot

#include <LeMonADE/utility/DepthIterator.h>
#include <LeMonADE/utility/MonomerGroup.h>

#include <LeMonADE-Viewer/Camera.h>

typedef struct {
  int button;
  int x;
  int y;
  int xold;
  int yold;
} Mouse;


template <class IngredientsType>
class LeMonADEOpenGL : public Fl_Gl_Window {

	void draw();
	int handle(int);



	Camera cam;

	IngredientsType& ingredients;
	const typename IngredientsType::molecules_type& molecules;

	int boxX;
	int boxY;
	int boxZ;

	bool showingBonds;
	bool foldingBack;		//
	//float point_size;				//the size of the point
	float bond_width;				//the width of the bonds

	Mouse mouse;    // Keeping track of mouse input

	//find connected molecules and put them in group
	//typedef NameDecorator< vector < MonomerGroup<typename IngredientsType::molecules_type> > > NamedMonomerGroupVector;
	//NamedMonomerGroupVector linearStrandsVector;
	//an open issue that I can´t call:  NamedMonomerGroupVector linearStrandsVector("linearStrands");
	typedef std::vector < MonomerGroup<typename IngredientsType::molecules_type> > MonomerGroupVector;

	MonomerGroupVector& linearStrandsVectorGroup;

	void draw_monomers_fkt(bool , bool);

	void show_bonds_fkt(bool showingBonds, bool foldingBack);

	float xSphere1[256]; // subdivision between s is element [1,15]
	float ySphere1[256]; // indexing lat+longs*(s+1)
	float zSphere1[256];

	float xSphere2[256];
	float ySphere2[256];
	float zSphere2[256];



public:
	LeMonADEOpenGL(IngredientsType& _ingredients, MonomerGroupVector& _linearStrandsVectorGroup, int x,int y,int w,int h,const char *l=0): ingredients(_ingredients), linearStrandsVectorGroup(_linearStrandsVectorGroup),molecules(_ingredients.getMolecules()),Fl_Gl_Window(x,y,w,h,l){
		 showingBonds = true;

		 foldingBack = false;
		// point_size = 1.0;
		 bond_width = 0.3;

		 //find the monomer in connected Structure
		 		       for ( uint g = 0; g < linearStrandsVectorGroup.size(); ++g)
		 		       {
		 		    	   std::cout << "group nr: "  << g  << " ; monos in group:" << linearStrandsVectorGroup[g].size() << std::endl;

		 		     	//  if(monoinBMC < groups[g].size())
		 		     		//  monoinBMC=groups[g].size();

		 		       }
	};

	virtual ~LeMonADEOpenGL(){};

	void initialize();

	void generatePovRayScript(std::string croppedFilenamePovray);

	bool screenshoot(const std::string&name);

	bool isFoldingBack() const {
		return foldingBack;
	}

	void setFoldingBack(bool isFoldingBack) {
		this->foldingBack = isFoldingBack;
	}

	bool isShowingBonds() const {
		return showingBonds;
	}

	void setShowingBonds(bool isShowingBonds) {
		this->showingBonds = isShowingBonds;
	}

	//int getRadiusMonomer() const {
	//	return point_size;
	//}

	void setRadiusMonomer(float radiusMonomer) {

		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			ingredients.modifyMolecules()[i].setRadius( radiusMonomer);
	}

	float getBondWidth() const {
		return bond_width;
	}

	void setBondWidth(float bondWidth) {
		bond_width = bondWidth;
	}

	float mod(float a, float N) {return a - N*floor(a/N);}

	/*void drawSphere(float radius, int lats, int longs, float x_cm, float y_cm, float z_cm) {
	  int i, j;
	  double MPI = 314159;
	  for(i = 0; i <= lats; i++) {
	  double lat0 = M_PI * (-0.5 + (double) (i - 1) / lats);
	  double z0  = sin(lat0);
	  double zr0 = cos(lat0);

	  double lat1 = M_PI * (-0.5 + (double) i / lats);
	 double z1 = sin(lat1);
	 double zr1 = cos(lat1);

	 glBegin(GL_QUAD_STRIP);
	 for(j = 0; j <= longs; j++) {
	 double lng = 2 * M_PI * (double) (j - 1) / longs;
	 double x = cos(lng);
	 double y = sin(lng);

	 //glNormal3f(x * zr0 +x_cm, y * zr0 + y_cm, z0 + z_cm);
	 glVertex3f(radius*x * zr0 +x_cm, radius*y * zr0 + y_cm, radius*z0 + z_cm);
	 //glNormal3f(x * zr1 +x_cm, y * zr1 + y_cm, z1 + z_cm);
	 glVertex3f(radius*x * zr1 +x_cm, radius*y * zr1 + y_cm, radius*z1 + z_cm);
	          }
	         glEnd();
	      }
	   }*/

	void precalculateSphere(int lats, int longs) {
	  int i, j;

	  int offset = ingredients.getSubdivisionSpheres()+1;
	  //double MPI = 314159;
/*	  for(i = 0; i <= lats; i++) {
	  double lat0 = M_PI * (-0.5 + (double) (i - 1) / lats);
	  double z0  = sin(lat0);
	  double zr0 = cos(lat0);

	  double lat1 = M_PI * (-0.5 + (double) i / lats);
	 double z1 = sin(lat1);
	 double zr1 = cos(lat1);

	 //glBegin(GL_QUAD_STRIP);
	 for(j = 0; j <= longs; j++) {
	 double lng = 2 * M_PI * (double) (j - 1) / longs;
	 double x = cos(lng);
	 double y = sin(lng);

	 xSphere1[j+i*offset]=x * zr0;
	 	 ySphere1[j+i*offset]=y * zr0;
	 	 zSphere1[j+i*offset]=z0;

	 	 xSphere2[j+i*offset]=x * zr1;
	 	 ySphere2[j+i*offset]=y * zr1;
	 	 zSphere2[j+i*offset]=z1;

	 //glNormal3f(x * zr0 +x_cm, y * zr0 + y_cm, z0 + z_cm);
	// glVertex3f(radius*x * zr0 +x_cm, radius*y * zr0 + y_cm, radius*z0 + z_cm);
	 //glNormal3f(x * zr1 +x_cm, y * zr1 + y_cm, z1 + z_cm);
	 //glVertex3f(radius*x * zr1 +x_cm, radius*y * zr1 + y_cm, radius*z1 + z_cm);
	          }
	       //  glEnd();
	      }
*/

	  int p = ingredients.getSubdivisionSpheres();
	  int q = ingredients.getSubdivisionSpheres();

	  int subdivision= ingredients.getSubdivisionSpheres();
	  float PI=3.14159265f;
	  //lat
	  for(int i = 0; i < subdivision; i++)
	  	       {
	  	          // One latitudinal triangle strip.
	  	          //glBegin(GL_TRIANGLE_STRIP);
	  	          //longs
	  	             for(int j = 0; j <= subdivision; j++)
	  	    		 {
	  	            	//xSphere1[j+i*offset]=cos( (float)(i+1)/q * PI/2.0 ) * cos( 2.0 * (float)j/p * PI );
	  	            	//ySphere1[j+i*offset]=cos( (float)(i+1)/q * PI/2.0 ) * sin( 2.0 * (float)j/p * PI );
	  	            	//zSphere1[j+i*offset]=sin( (float)(i+1)/q * PI/2.0 );

	  	            	//xSphere2[j+i*offset]=cos( (float)i/q * PI/2.0 ) * cos( 2.0 * (float)j/p * PI );
	  	            	//ySphere2[j+i*offset]=cos( (float)i/q * PI/2.0 ) * sin( 2.0 * (float)j/p * PI );
	  	            	//zSphere2[j+i*offset]=sin( (float)i/q * PI/2.0 );

	  	            	xSphere1[j+i*offset]=cos( (-0.5+(float)(i+1)/q)* PI ) * cos( 2.0 * (float)j/p * PI );
	  	            	ySphere1[j+i*offset]=cos( (-0.5+(float)(i+1)/q)* PI ) * sin( 2.0 * (float)j/p * PI );
	  	            	zSphere1[j+i*offset]=sin( (-0.5+(float)(i+1)/q)* PI );

	  	            	xSphere2[j+i*offset]=cos( (-0.5+(float)(i)/q)* PI ) * cos( 2.0 * (float)j/p * PI );
	  	            	ySphere2[j+i*offset]=cos( (-0.5+(float)(i)/q)* PI ) * sin( 2.0 * (float)j/p * PI );
	  	            	zSphere2[j+i*offset]=sin( (-0.5+(float)(i)/q)* PI );

	  	                //glVertex3f( radius * cos( (float)(j+1)/q * PI/2.0 ) * cos( 2.0 * (float)i/p * PI ) + x_draw,
	  	                //		radius * sin( (float)(j+1)/q * PI/2.0 )+ y_draw,
	  	                //		radius * cos( (float)(j+1)/q * PI/2.0 ) * sin( 2.0 * (float)i/p * PI ) +z_draw);
	  	                //glVertex3f( radius * cos( (float)j/q * PI/2.0 ) * cos( 2.0 * (float)i/p * PI ) +x_draw,
	  	                //		radius * sin( (float)j/q * PI/2.0 )+ y_draw,
	  	                //		radius * cos( (float)j/q * PI/2.0 ) * sin( 2.0 * (float)i/p * PI ) +z_draw);
	  	    		 }
	  	          //glEnd();
	  	       }


	   }
};

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::generatePovRayScript(std::string croppedFilenamePovray){

    std::ofstream afile;
	std::string afileName = croppedFilenamePovray+".pov";
	afile.open(afileName.c_str(),std::ios::trunc);
	afile << "// povray +I"<<croppedFilenamePovray << ".pov +O"<<croppedFilenamePovray << ".png +W"<<this->w() <<" +H" << this->h() << " +P " << std::endl;
	afile << "// +UA for transparency mask" << std::endl;
	afile << "" << std::endl;
	afile << "#version 3.5;" << std::endl << std::endl;
	afile << "#include "<< "\"" << "colors.inc" << "\"" << std::endl;
	afile << "" << std::endl;
	afile << "global_settings {assumed_gamma 1.0 noise_generator 2}" << std::endl;
	afile << "" << std::endl;

	// camera

	afile << "camera{" << std::endl;
	float radius = 1.5*boxZ;

	float pi = atan(1)*4;
	float PhiPov = (-cam.getCamPhiRot()) * pi / 180.0;
	float ThetaPov1 = (-cam.getCamThetaRot()) * pi / 180.0;
	float ThetaPov2 = (cam.getCamThetaRot()) * pi / 180.0;

	// need clauses if position of camera is positive
	if((-cam.getCamYPos()) >=0)
	{	afile << "location <" << 0 << " , " << 0 << " , " << -cam.getCamYPos() << " > " << std::endl;

    afile << " right -x*" << this->w() << "/" << this->h()<<std::endl;
    afile << " look_at <0.0, 0.0, 0.0>" << std::endl;
    afile << " translate <" << cam.getCamXPos() << ", " << -cam.getCamZPos() << ", " << 0.0 << ">" << std::endl;
	}
	else
		{	afile << "location <" << 0 << " , " << 0 << " , " << 0 << " > " << std::endl;

		    afile << " right -x*" << this->w() << "/" << this->h()<<std::endl;
		    afile << " look_at <0.0, 0.0, " << (-cam.getCamYPos()) <<">" << std::endl;
		    afile << " translate <" << cam.getCamXPos() << ", " << -cam.getCamZPos() << ", " << 0.0 << ">" << std::endl;
			}

	double aspectRatio = (this->w() > this->h())? float(this->w())/float(this->h()) : float(this->h())/float(this->w());
	double fovy = 45.0; //degrees - fov is in y in openGL, povRay uses in x
	double anglefovx = 2 * atan ( ((1.0*this->w())/this->h()) * tan(fovy/2.0/180*3.1416) )* 180.0/3.1416;
	afile << " angle " << anglefovx<< std::endl;

	afile << "rotate  < 90, 0, 0 >" << std::endl;

		afile << "rotate  < 0, 0, " << -cam.getCamPhiRot() << " >" << std::endl;
		//afile << "rotate  <" << -cam.getCamThetaRot() << ", 0 , 0 > "<< std::endl;
		afile << "rotate  <" << cam.getCamThetaRot() << ", 0 , 0 > "<< std::endl;

		afile << " translate <" << 0.5*boxX  <<" , " << 0.5*boxY <<" , " << 0.5*boxZ << ">" << std::endl;

		afile << "}" << std::endl;

	afile << "" << std::endl;
	afile << "// background color" << std::endl;
	afile << "sky_sphere{pigment{color rgb< 0.0, 0.0, 0.0 > }}" << std::endl;
	afile << "" << std::endl;
	afile << "// light source" << std::endl;
	afile << "light_source{<1000.0, 1000.0, -200.0> color White}" << std::endl;

	afile << "light_source{< " << cam.getCamXPos() << " , " << -cam.getCamZPos() << " , " << -cam.getCamYPos() << " > color White"<< std::endl;
	//afile << "fade_distance " << -(cam.getCamYPos()+0.5*boxY) << std::endl;
	afile << "//fade_distance " << 100 << std::endl;
	afile << "//fade_power 3" << std::endl;
	afile << "rotate  < 90, 0, 0 >" << std::endl;

		afile << "rotate  < 0, 0, " << -cam.getCamPhiRot() << " >" << std::endl;
		//afile << "rotate  <" << -cam.getCamThetaRot() << ", 0 , 0 > "<< std::endl;
		afile << "rotate  <" << cam.getCamThetaRot() << ", 0 , 0 > "<< std::endl;

		afile << "// translate <" << 0.5*boxX  <<" , " << 0.5*boxY <<" , " << 0.5*boxZ << ">" << std::endl;

	//afile << "rotate  < -90, 0, 0 >" << std::std::endl;
	//	afile << "rotate  < 0, 0, " << -cam.getCamPhiRot() << " >" << std::std::endl;
		//afile << "rotate  <" <<cam.getCamThetaRot()* cam.getCamThetaRotAxisX()<< ", 0 , " << cam.getCamThetaRot()*cam.getCamThetaRotAxisZ() << "  > "<< std::std::endl;
	//	afile << "rotate  <" << -cam.getCamThetaRot() << ", 0 , 0 > "<< std::std::endl;
	//	afile << " translate <" << 0.5*boxX  <<" , " << 0.5*boxY <<" , " << -0.5*boxZ << ">" << std::endl;
	afile << "}" << std::endl;

	afile << "" << std::endl;
	afile << "// objects (monomers)  " << std::endl;

	// das ist jetzt die reale monomer-Position (STIMMT DAS SCHON SO?)
	for(size_t n=0; n< molecules.size(); ++n){
	    	  if(molecules[n].isVisible())
	    	  {
	    		  if (ingredients.isSmoothing() == false){

	    			  if (foldingBack == true) {
	    				  afile << "sphere{< " << ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX)  << ", " << ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY)  << ", " << (((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ) )  << "> " << molecules[n].getRadius() << std::endl;

	    			  }
	    			  else
	    			  	  //afile << "sphere{< " << linearStrandsVector[n].operator[](m)[0] - 0.5*boxX << ", " << linearStrandsVector[n].operator[](m)[1] - 0.5*boxX << ", " << -linearStrandsVector[n].operator[](m)[2] + 0.5 * boxZ << "> 2" << std::endl;
	    			  afile << "sphere{< " << (molecules[n][0]+ingredients.getTranslationInX())  << ", " << (molecules[n][1]+ingredients.getTranslationInY()) << ", " << (molecules[n][2]+ingredients.getTranslationInZ())  << "> " << (molecules[n].getRadius()) << std::endl;
	    		  }
	    		  else
	    		  {
	    			  if (foldingBack == true) {
	    				  afile << "sphere{< " << ((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX)  ) )  << ", " << ((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) ) )  << ", " << (((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) ) ))  << "> " << (molecules[n].getRadius()) << std::endl;

	    			  }
	    			  else
	    			  afile << "sphere{< " << (molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX())  << ", " << (molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY())  << ", " << (molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ())  << "> " << (molecules[n].getRadius()) << std::endl;
	    		  }
		afile << " pigment {color rgb<" << molecules[n].getColor().getX() << ", " << molecules[n].getColor().getY() << ", " << molecules[n].getColor().getZ() <<  ">}" << std::endl;
		afile << " finish {phong 5.0 phong_size 40 reflection rgb<0.0, 0.0, 0.0> roughness 0.05 ambient 0.1 diffuse 0.9} }" << std::endl;

	      }

	}
	afile << std::endl;

	//bonds:

	if (showingBonds == true) {
		for(size_t n=0; n< molecules.size(); ++n){

	    	  size_t linkcount = ingredients.getMolecules().getNumLinks(n);		// check for the number of links the current monomer has

	    	  if(molecules[n].isVisible())
	    	  {
	    		  for(size_t k=0; k < linkcount; ++k)
	    			  {		  size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, k); 	// search for the monomers connected to the current

	    			  //draw only one bond
	    			  if(neighboridx < n)
	    			  {
	    		  if (ingredients.isSmoothing() == false)
	    		  {
	    		 	    //afile << "sphere{< " << linearStrandsVector[n].operator[](m)[0] - 0.5*boxX << ", " << linearStrandsVector[n].operator[](m)[1] - 0.5*boxX << ", " << -linearStrandsVector[n].operator[](m)[2] + 0.5 * boxZ << "> 2" << std::endl;
	    		 	   // afile << "sphere{< " << linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << "> " << (point_size/10.0f) << std::endl;
                       VectorFloat3 bondDirection;
                       bondDirection.setX(1.0f*(molecules[n][0]-ingredients.getMolecules()[neighboridx][0]));
                       bondDirection.setY(1.0f*(molecules[n][1]-ingredients.getMolecules()[neighboridx][1]));
                       bondDirection.setZ(1.0f*(molecules[n][2]-ingredients.getMolecules()[neighboridx][2]));

                       float bondLength= bondDirection.getLength();

                       if((bondLength>0.1) && (bondLength<6.0))
                       {
                      // bondDirection.normalize();

	    		 	   //afile << "cylinder{ < " << linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    		 	   afile << "cylinder{ <0,0,0> " << //linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    		 			    ", <" <<(-bondDirection[0]) << "," << -(bondDirection[1]) <<"," << -(bondDirection[2]) << ">, "  << bond_width <<
	    		 			  // ingredients.getMolecules()[neighboridx][0]  << ", " << ingredients.getMolecules()[neighboridx][1]  << ", " << (-ingredients.getMolecules()[neighboridx][2])  << "> "  <<
	    		 			 "  texture{ pigment{ gradient <"<< bondDirection[0]/bondDirection.getLength() <<"," << bondDirection[1]/bondDirection.getLength() <<"," << (bondDirection[2]/bondDirection.getLength()) <<
	    		 			 "> color_map{ [0.0 color rgb<" << ingredients.getMolecules()[neighboridx].getColor().getX() << ", " << ingredients.getMolecules()[neighboridx].getColor().getY() << ", " << ingredients.getMolecules()[neighboridx].getColor().getZ() <<  "> ]" <<
	    		 			 "[1.0 color rgb<" << molecules[n].getColor().getX() << ", " << molecules[n].getColor().getY() << ", " << molecules[n].getColor().getZ() <<  "> ]} scale "<< bondLength<<
	    		 			 " translate <" << (-bondDirection[0]) <<"," << -(bondDirection[1]) <<"," << -(bondDirection[2]) <<">} finish { phong 1}} translate < ";
	    		 			//ingredients.getMolecules()[neighboridx][0]  << ", " << ingredients.getMolecules()[neighboridx][1]  << ", " << (-ingredients.getMolecules()[neighboridx][2])  << "> "  <<

	    		 	   if(foldingBack == false)
	    		 	   {
	    		 		   afile << (molecules[n][0]+ingredients.getTranslationInX())  << ", " << (molecules[n][1]+ingredients.getTranslationInY())  << ", " << (molecules[n][2]+ingredients.getTranslationInZ())  << ">";
	    		 	   }
	    		 	   else
	    		 	   {
	    		 		   afile << ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX) << ", " << ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY)  << ", " << ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ)  << ">";
	    		 	   }

	    		 	   afile << "scale <1,1,1> rotate<0,0,0> translate<0,0,0> }" <<std::endl;

                       }


	    		  }
	    		  else //smoothing true
		    		  {
	    			                   VectorFloat3 bondDirection;
	    			                        bondDirection.setX(1.0f*(molecules[n].getSmoothCoordinate()[0]-ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]));
	    			                        bondDirection.setY(1.0f*(molecules[n].getSmoothCoordinate()[1]-ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]));
	    			                        bondDirection.setZ(1.0f*(molecules[n].getSmoothCoordinate()[2]-ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]));

	    			                        float bondLength= bondDirection.getLength();

	    			                                               if((bondLength>0.1) && (bondLength<6.0))
	    			                                               {
	    			 	    		 	   //afile << "cylinder{ < " << linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    			 	    		 	   afile << "cylinder{ <0,0,0> " << //linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    			 	    		 			    ", <" <<(-bondDirection[0]) << "," << -(bondDirection[1]) <<"," << -(bondDirection[2]) << ">, "  << bond_width <<
	    			 	    		 			  // ingredients.getMolecules()[neighboridx][0]  << ", " << ingredients.getMolecules()[neighboridx][1]  << ", " << (-ingredients.getMolecules()[neighboridx][2])  << "> "  <<
	    			 	    		 			 "  texture{ pigment{ gradient <"<< bondDirection[0]/bondDirection.getLength() <<"," << bondDirection[1]/bondDirection.getLength() <<"," << (bondDirection[2]/bondDirection.getLength()) <<
	    			 	    		 			 "> color_map{ [0.0 color rgb<" << ingredients.getMolecules()[neighboridx].getColor().getX() << ", " << ingredients.getMolecules()[neighboridx].getColor().getY() << ", " << ingredients.getMolecules()[neighboridx].getColor().getZ() <<  "> ]" <<
	    			 	    		 			 "[1.0 color rgb<" << molecules[n].getColor().getX() << ", " << molecules[n].getColor().getY() << ", " << molecules[n].getColor().getZ() <<  "> ]} scale "<< bondLength<<
	    			 	    		 			 " translate <" << (-bondDirection[0]) <<"," << -(bondDirection[1]) <<"," << -(bondDirection[2]) <<">} finish { phong 1}} translate < ";

	    			 	    		 	 if(foldingBack == false)
	    			 	    		 	 	{
	    			 	    		 	 	    afile << (molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX())  << ", " << (molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY())  << ", " << (molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ())  << ">";
	    			 	    		 	 	}
	    			 	    		 	else
	    			 	    		 	 	 {
	    			 	    		 	 	    afile << mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX) << ", " << mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY)  << ", " << mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ)  << ">";
	    			 	    		 	 	 }

	    			 	    		 	afile << "scale <1,1,1> rotate<0,0,0> translate<0,0,0> }" <<std::endl;
	    			                                               }

		    		 	 }
	    			  }

	    		  }
	    			  }

	      }
	}






	afile << "" << std::endl;
	// BOND VECTORS EINBINDEN!!!
	afile.close();


}


template <class IngredientsType>
bool LeMonADEOpenGL<IngredientsType>::screenshoot(const std::string&name) {


}



template <class IngredientsType>
int LeMonADEOpenGL<IngredientsType>::handle(int e) {

	int handled = 1;
	//static int prev_x;
	//static int prev_y;

	//int mouse_x, mouse_y;
	int delta_x=0, delta_y=0;

	switch (e) {
	case FL_ENTER: cursor(FL_CURSOR_CROSS); break;
	case FL_LEAVE: cursor(FL_CURSOR_DEFAULT); break;

	case FL_MOUSEWHEEL:
						cam.setHoldingForwardMouse(Fl::event_dy());
		break;

	case FL_RELEASE:

	    mouse.x = (Fl::event_x());
	    mouse.y = (Fl::event_y());
	    mouse.button = 0;
	    break;
	  case FL_PUSH:


			cam.setCamPhiRotSpeed(0.0);
			cam.setCamThetaRotSpeed(0.0);


	    mouse.x = (Fl::event_x());
	    mouse.y = (Fl::event_y());
	    mouse.button = (Fl::event_button());
	    break;

	case FL_DRAG: if(Fl::event_button1())
	{
		//std::std::cout << Fl::event_x() << std::endl;
		mouse.x=Fl::event_x();
		mouse.y=Fl::event_y();
		delta_x=mouse.x-mouse.xold;//prev_x;
		delta_y=mouse.y-mouse.yold;//prev_y;

		 cam.handleMouseMove(delta_x, delta_y, boxX, boxY, boxZ);
		 redraw();
	}

	/*	if((e.event_button1 	( 		) 	event.motion.state == SDL_BUTTON(SDL_BUTTON_LEFT)))
	   {
	  	  cam.handleMouseMove(event.motion.xrel, event.motion.yrel, boxX, boxY, boxZ);
	   }  */
	break;

	case FL_KEYDOWN:

			    if (int(Fl::event_key()) == int('i'))
			      {cam.setHoldingForwardI(true);}

			    if (int(Fl::event_key()) == int('o'))
			      {cam.setHoldingBackwardO(true);}

			    if (int(Fl::event_key()) == int('w'))
			      {cam.setHoldingUpW(true);}

			    if (int(Fl::event_key()) == int('s'))
			      {cam.setHoldingDownS(true);}

			    if (int(Fl::event_key()) == int('a'))
			      {cam.setHoldingLeftA(true);}

			    if (int(Fl::event_key()) == int('d'))
			      {cam.setHoldingRightD(true);}

			    if (int(Fl::event_key()) == int('r')) //resets camera
			    {
			    	//Camera rotation
			    		  				cam.setCamPhiRot(0.0f);
									cam.setCamThetaRot(0.0f);

									cam.setCamPhiRotSpeed(0.0f);
									cam.setCamThetaRotSpeed(0.0f);

									//Camera rotation axis
									cam.setCamThetaRotAxisX(1.0f);
									cam.setCamThetaRotAxisZ(0.0f);

		    //  glTranslatef(-cam.getCamXPos(),-cam.getCamYPos(),-cam.getCamZPos());    // Translate the model

									// Camera position
			    		  				cam.setCamXPos(0.0f);
			    		  				cam.setCamYPos(-2*this->ingredients.getBoxY());
			    		  				cam.setCamZPos(0.0f);
			    		  			}
			 break;

	case FL_KEYUP:

		    if (int(Fl::event_key()) == int('i'))
		      {cam.setHoldingForwardI(false);}

		    if (int(Fl::event_key()) == int('o'))
		      {cam.setHoldingBackwardO(false);}

		    if (int(Fl::event_key()) == int('w'))
		      {cam.setHoldingUpW(false);}

		    if (int(Fl::event_key()) == int('s'))
		      {cam.setHoldingDownS(false);}

		    if (int(Fl::event_key()) == int('a'))
		      {cam.setHoldingLeftA(false);}

		    if (int(Fl::event_key()) == int('d'))
		      {cam.setHoldingRightD(false);}


		 break;
	}



	mouse.xold=mouse.x;
	mouse.yold=mouse.y;

	return Fl_Gl_Window::handle(e);
}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::initialize(){


	//cam.setCamZPos(2*this->ingredients.getBoxZ());
	cam.setCamYPos(-2*this->ingredients.getBoxY());

	boxX = this->ingredients.getBoxX();
	boxY = this->ingredients.getBoxY();
	boxZ = this->ingredients.getBoxZ();

	//fill the groups with connected structures
	//linearStrandsVector.setName("linearStrands");
	//fill_connected_groups( this->ingredients.getMolecules(), linearStrandsVector, MonomerGroup<typename IngredientsType::molecules_type>(&(this->ingredients.getMolecules())),alwaysTrue() );

	// in the first frame we color all monomer from red to blue
		 /*	for(size_t n=0; n< linearStrandsVectorGroup.size(); ++n){
		 		  float colorvar = 1./(linearStrandsVectorGroup.size())*n;

		 		  for(size_t m=0; m< linearStrandsVectorGroup[n].size(); ++m){

		 			 ingredients.modifyMolecules()[linearStrandsVectorGroup[n].trueIndex(m)].setColor(colorvar, 0, 1-colorvar);



		 		  }
		 		}
		 	*/

	for(size_t n=0; n< molecules.size(); ++n){
			 		  float colorvar = 1./(molecules.size())*n;
			 		  	  ingredients.modifyMolecules()[n].setColor(colorvar, 0, 1-colorvar);

			 		}
	precalculateSphere(ingredients.getSubdivisionSpheres(),ingredients.getSubdivisionSpheres());

}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw(){

	if (!valid()) {

		glLoadIdentity();

		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);           //schwarzer Hintergrund (dazu mehr in der render-Funktion)

		glShadeModel(GL_SMOOTH);                        //weichere Farbübergänge auf Körpern

		GLint windowWidth = this->w();
		GLint windowHeight = this->h();

		GLfloat fieldOfView = 45.0f;                 // Define our field of view (i.e. how quickly foreshortening occurs)
		GLfloat near        = 1.0f;                  // The near (Z Axis) point of our viewing frustrum (default 1.0f)
		GLfloat far         = 1500.0f;               // The far  (Z Axis) point of our viewing frustrum (default 1500.0f)

		// Setup our viewport to be the entire size of the window
		glViewport(0, 0, (GLsizei)windowWidth, (GLsizei)windowHeight);

		// Change to the projection matrix, reset the matrix and set up our projection
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();

		// http://nehe.gamedev.net/article/replacement_for_gluperspective/21002/
		// The following code is a fancy bit of math that is eqivilant to calling:
		// gluPerspective(fieldOfView/2.0f, width/height , near, far);
		// We do it this way simply to avoid requiring glu.h
		GLfloat aspectRatio = (windowWidth > windowHeight)? float(windowWidth)/float(windowHeight) : float(windowHeight)/float(windowWidth);
		GLfloat fH = tan( float(fieldOfView / 360.0f * 3.14159f) ) * near;
		GLfloat fW = fH * aspectRatio;

		std::cout << "Width: " << windowWidth << std::endl;
		std::cout << "Height: " << windowHeight << std::endl;
		std::cout << "aspectRatio: " << aspectRatio << std::endl;

		glFrustum(-fW, fW, -fH, fH, near, far);

		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		// ----- OpenGL settings -----

				    glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set out clear colour to black, full alpha

				    glShadeModel(GL_SMOOTH);    // Enable (gouraud) shading

				    glEnable(GL_DEPTH_TEST);    // Enable depth testing

				    glClearDepth(1.0f);         // Clear the entire depth of the depth buffer

				    glDepthFunc(GL_LEQUAL);		// Set our depth function to overwrite if new value less than or equal to current value

				    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Ask for nicest perspective correction

				    //glEnable(GL_CULL_FACE); // Do not draw polygons facing away from us

				    glLineWidth(2.0f);			// Set a 'chunky' line width

	}
	// Clear the screen and depth buffer
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// Reset the matrix
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	// Move the simulation box to the right position in space
	//glTranslatef(-cam.getCamXPos(),-cam.getCamYPos(),-cam.getCamZPos());

/*
//std::cout << cam.getViewXPos() << " " << cam.getViewYPos()<< " " << cam.getViewZPos() << std::endl;
	float distance = sqrtf(cam.getCamXPos()*cam.getCamXPos()+cam.getCamYPos()*cam.getCamYPos()+cam.getCamZPos()*cam.getCamZPos());
	glTranslated(0.0, 0.0, -distance);
	glRotatef(-90.0, 1.0f, 0.0f, 0.0f);
	//glTranslatef(-0.5*boxX, -0.5*boxY, -0.5*boxZ);
	//glRotated(-twist, 0.0, 0.0, 1.0);
		      glRotated(-cam.getCamThetaRot(), 1.0, 0.0, 0.0);
		      glRotated(cam.getCamPhiRot(), 0.0, 0.0, 1.0);
		      //glTranslatef(-0.5*boxX, -0.5*boxY, -0.5*boxZ);
		      glTranslatef(-0.5*boxX+cam.getViewXPos(), -0.5*boxY+cam.getViewYPos(), -0.5*boxZ+cam.getViewZPos());
*/
	glTranslatef(-cam.getCamXPos(),cam.getCamZPos(),cam.getCamYPos());

	glRotatef(-90.0, 1.0f, 0.0f, 0.0f);
	//Rotate the simulation box accordingly to the calculated "camera rotation" angles
	//Rotation around center of the simulation box
	glRotatef(cam.getCamPhiRot(), 0.0f, 0.0f, 1.0f);
	glRotatef(-cam.getCamThetaRot(), 1.0f, 0.0f, 0.0f);
	//glRotatef(cam.getCamThetaRot(), -cam.getCamThetaRotAxisX(), 0.0f, -cam.getCamThetaRotAxisZ());
	//move the simulation box with the center into the origin of coordinates
	glTranslatef(-0.5*boxX, -0.5*boxY, -0.5*boxZ);

	//glPushMatrix();

	//glTranslatef(0.0f, 200.0f, 0.0f);

	//drawGround();

	//  glPopMatrix();


	//   glTranslatef(0.0f, 0.0f, -128.0f); //everything is now relativ to this

	glLineWidth(2.0);
	// drawing the horizontal edges of the box
	glBegin(GL_LINE_LOOP);
	glColor3f(1, 1, 1);
	glVertex3f(0, 0, 0);
	glVertex3f(0, 0, boxZ);
	glVertex3f(boxX, 0, boxZ);
	glVertex3f(boxX, 0, 0);
	glEnd();

	glBegin(GL_LINE_LOOP);
	glVertex3f(0, boxY, 0);
	glVertex3f(0, boxY, boxZ);
	glVertex3f(boxX, boxY, boxZ);
	glVertex3f(boxX, boxY, 0);
	glEnd();

	// drawing the vertical edges of the box
	glBegin(GL_LINES);
	glVertex3f(0, 0, 0);
	glVertex3f(0, boxY, 0);
	glVertex3f(0, 0, boxZ);
	glVertex3f(0, boxY, boxZ);
	glVertex3f(boxX, 0, boxZ);
	glVertex3f(boxX, boxY, boxZ);
	glVertex3f(boxX, 0, 0);
	glVertex3f(boxX, boxY, 0);
	glEnd();

	// drawing a single square in one corner of the box (for scale/size comparison)
	glBegin(GL_QUADS);
	glVertex3f(-0.5, -0.5, boxZ);
	glVertex3f(+0.5, -0.5, boxZ);
	glVertex3f(+0.5, +0.5, boxZ);
	glVertex3f(-0.5, +0.5, boxZ);
	glEnd();

	// drawing coordinate system in the origin
	glBegin(GL_LINES);
	glColor3f(1, 0, 0);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10+boxX, -10, -10);
	glColor3f(0, 1, 0);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10, -10+boxY, -10);
	glColor3f(0, 0, 1);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10, -10, -10+boxZ);
	glEnd();

	draw_monomers_fkt(1, foldingBack);
	show_bonds_fkt( showingBonds, foldingBack);

	//  SDL_GL_SwapBuffers();


	cam.calculateCameraMovement();

	// Move our camera
	cam.moveCamera();

	//  SDL_Delay(100);
}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw_monomers_fkt(bool smoothing, bool foldingBack){

	// drawing the monomers (represented by cubes) and sorted by groups (e.g. chains), which are represented by using different colors

	if (ingredients.isSmoothing() == false) {



		if (foldingBack == true) {

			if (ingredients.isDrawingMonomersAsSpheres() == false) {
				for(size_t n=0; n< molecules.size(); ++n){

						if(molecules[n].isVisible())
						{
							float x_draw = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
							float y_draw = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
							float z_draw = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);
							glPointSize(molecules[n].getRadius()*10.0f);
							glBegin(GL_POINTS);
							// glColor3f(colorvar, 0, 1-colorvar);
							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());
							glVertex3f(x_draw, y_draw, z_draw);
							glEnd();
						}

				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n){

						if(molecules[n].isVisible())
						{
							float x_draw = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
							float y_draw = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
							float z_draw = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);

							float radius = molecules[n].getRadius();


							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

							for(int lats = 0; lats < subdivision; lats++)
							{
								// One latitudinal triangle strip.
								glBegin(GL_TRIANGLE_STRIP);
								for(int longs = 0; longs <= subdivision; longs++)
								{
									glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset]+ y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);

									glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);

								}
								glEnd();
							}
						}

				}
			}
		}

		else {

			if (ingredients.isDrawingMonomersAsSpheres() == false) {
				for(size_t n=0; n< molecules.size(); ++n){


						if(molecules[n].isVisible())
						{
							float x_draw = molecules[n][0]+ingredients.getTranslationInX();
							float y_draw = molecules[n][1]+ingredients.getTranslationInY();
							float z_draw = molecules[n][2]+ingredients.getTranslationInZ();
							glPointSize(molecules[n].getRadius()*10.0f);
							glBegin(GL_POINTS);
							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

							//glColor3f(colorvar, 0, 1-colorvar);
							glVertex3f(x_draw, y_draw, z_draw);
							glEnd();


						}

				}



			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n){


						if(molecules[n].isVisible())
						{
							float x_draw = molecules[n][0]+ingredients.getTranslationInX();
							float y_draw = molecules[n][1]+ingredients.getTranslationInY();
							float z_draw = molecules[n][2]+ingredients.getTranslationInZ();

							float radius = molecules[n].getRadius();


							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

							for(int lats = 0; lats < subdivision; lats++)
							{
								// One latitudinal triangle strip.
								glBegin(GL_TRIANGLE_STRIP);
								for(int longs = 0; longs <= subdivision; longs++)
								{
									glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset]+ y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);

									glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);

								}
								glEnd();
							}
						}

				}
			}

		}

	}
	//smoothing here
	else{
		if (foldingBack == true) {
			// glPointSize(point_size*10.0f);

			if (ingredients.isDrawingMonomersAsSpheres() == false) {
				for(size_t n=0; n< molecules.size(); ++n){


						if(molecules[n].isVisible())
						{
							float x_draw = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
							float y_draw = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
							float z_draw = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);
							glPointSize(molecules[n].getRadius()*10.0f);
							glBegin(GL_POINTS);
							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

							//glColor3f(colorvar, 0, 1-colorvar);
							glVertex3f(x_draw, y_draw, z_draw);
							glEnd();
						}

				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;


				for(size_t n=0; n< molecules.size(); ++n){


						if(molecules[n].isVisible())
						{
							float x_draw = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
							float y_draw = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
							float z_draw = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);
							float radius = molecules[n].getRadius();


							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

							for(int lats = 0; lats < subdivision; lats++)
							{
								// One latitudinal triangle strip.
								glBegin(GL_TRIANGLE_STRIP);
								for(int longs = 0; longs <= subdivision; longs++)
								{
									glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset]+ y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);

									glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);

								}
								glEnd();
							}
						}

				}
			}

		}
		else{
			//glPointSize(point_size*10.0f);

			if (ingredients.isDrawingMonomersAsSpheres() == false) {
				for(size_t n=0; n< molecules.size(); ++n){


						if(molecules[n].isVisible())
						{
							float x_draw = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
							float y_draw = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
							float z_draw = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();
							glPointSize(molecules[n].getRadius()*10.0f);
							glBegin(GL_POINTS);
							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

							//glColor3f(colorvar, 0, 1-colorvar);
							glVertex3f(x_draw, y_draw, z_draw);
							glEnd();
						}

				}

			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;


				for(size_t n=0; n< molecules.size(); ++n){


						if(molecules[n].isVisible())
						{
							float x_draw = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
							float y_draw = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
							float z_draw = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

							float radius = molecules[n].getRadius();


							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

							for(int lats = 0; lats < subdivision; lats++)
							{
								// One latitudinal triangle strip.
								glBegin(GL_TRIANGLE_STRIP);
								for(int longs = 0; longs <= subdivision; longs++)
								{
									glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset]+ y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);

									glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);

								}
								glEnd();
							}

						}

				}
			}

		}

	}


}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::show_bonds_fkt(bool showingBonds, bool foldingBack) {

	if (showingBonds == true) {

		if (ingredients.isSmoothing() == false) {
			if (foldingBack == true) {
				glLineWidth(bond_width);

				for(size_t n=0; n< molecules.size(); ++n){

						if(molecules[n].isVisible())
						{
							//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
							size_t linkcount = ingredients.getMolecules().getNumLinks(n);

							float x_draw_mono_orig = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
							float y_draw_mono_orig = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
							float z_draw_mono_orig = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);


							for(size_t nn=0; nn < linkcount; ++nn){

								//size_t neighboridx = linearStrandsVectorGroup[n].copyGroup().getNeighborIdx(m, nn); 	// search for the monomers connected to the current
								size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

															//draw only one bond
															if(neighboridx < n)
															{
								//float x_draw_mono_nn = ((((linearStrandsVectorGroup[n].operator[](neighboridx)[0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
								//float y_draw_mono_nn = ((((linearStrandsVectorGroup[n].operator[](neighboridx)[1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
								//float z_draw_mono_nn = ((((linearStrandsVectorGroup[n].operator[](neighboridx)[2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);

								float x_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
								float y_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
								float z_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);



								if((x_draw_mono_orig-x_draw_mono_nn)*(x_draw_mono_orig-x_draw_mono_nn)+(y_draw_mono_orig-y_draw_mono_nn)*(y_draw_mono_orig-y_draw_mono_nn)+(z_draw_mono_orig-z_draw_mono_nn)*(z_draw_mono_orig-z_draw_mono_nn) <= 20)
								{
									glBegin(GL_LINES);						// draw bond
									glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
									glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
									glEnd();
								}
															}
							}


						}

				}

			}
			else
			{			  glLineWidth(bond_width);

			for(size_t n=0; n< molecules.size(); ++n){



					if(molecules[n].isVisible())
					{
						//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);


						float x_draw_mono_orig = (molecules[n][0]+ingredients.getTranslationInX());
						float y_draw_mono_orig = (molecules[n][1]+ingredients.getTranslationInY());
						float z_draw_mono_orig = (molecules[n][2]+ingredients.getTranslationInZ());


						for(size_t nn=0; nn < linkcount; ++nn){
							//size_t neighboridx = linearStrandsVectorGroup[n].copyGroup().getNeighborIdx(m, nn); 	// search for the monomers connected to the current
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{
							//float x_draw_mono_nn = linearStrandsVectorGroup[n].operator[](neighboridx)[0]+ingredients.getTranslationInX();
							//float y_draw_mono_nn = linearStrandsVectorGroup[n].operator[](neighboridx)[1]+ingredients.getTranslationInY();
							//float z_draw_mono_nn = linearStrandsVectorGroup[n].operator[](neighboridx)[2]+ingredients.getTranslationInZ();

							float x_draw_mono_nn = ingredients.getMolecules()[neighboridx][0]+ingredients.getTranslationInX();
							float y_draw_mono_nn = ingredients.getMolecules()[neighboridx][1]+ingredients.getTranslationInY();
							float z_draw_mono_nn = ingredients.getMolecules()[neighboridx][2]+ingredients.getTranslationInZ();


							glBegin(GL_LINES);						// draw bond
							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
							glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
							glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
							glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
							glEnd();
							}
						}


					}

			}

			}

		}
		else // smoothing true
		{


			if (foldingBack == true) {
				glLineWidth(bond_width);

				for(size_t n=0; n< molecules.size(); ++n){

						if(molecules[n].isVisible())
						{
							//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
							size_t linkcount = ingredients.getMolecules().getNumLinks(n);

							float x_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
							float y_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
							float z_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);


							for(size_t nn=0; nn < linkcount; ++nn){
								//size_t neighboridx = linearStrandsVectorGroup[n].copyGroup().getNeighborIdx(m, nn); 	// search for the monomers connected to the current
								size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

															//draw only one bond
															if(neighboridx < n)
															{

								//float x_draw_mono_nn = mod((mod(linearStrandsVectorGroup[n].operator[](neighboridx).getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
								//float y_draw_mono_nn = mod((mod(linearStrandsVectorGroup[n].operator[](neighboridx).getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
								//float z_draw_mono_nn = mod((mod(linearStrandsVectorGroup[n].operator[](neighboridx).getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);
								float x_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
								float y_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
								float z_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);


								if((x_draw_mono_orig-x_draw_mono_nn)*(x_draw_mono_orig-x_draw_mono_nn)+(y_draw_mono_orig-y_draw_mono_nn)*(y_draw_mono_orig-y_draw_mono_nn)+(z_draw_mono_orig-z_draw_mono_nn)*(z_draw_mono_orig-z_draw_mono_nn) <= 20)
								{
									glBegin(GL_LINES);						// draw bond
									glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
									glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
									glEnd();
								}
															}
							}


						}

				}

			}
			else
			{			  glLineWidth(bond_width);

			for(size_t n=0; n< molecules.size(); ++n){

					if(molecules[n].isVisible())
					{
						//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
						float y_draw_mono_orig = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
						float z_draw_mono_orig = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();


						for(size_t nn=0; nn < linkcount; ++nn){
							//size_t neighboridx = linearStrandsVectorGroup[n].copyGroup().getNeighborIdx(m, nn); 	// search for the monomers connected to the current
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

																						//draw only one bond
																						if(neighboridx < n)
																						{

							//float x_draw_mono_nn = linearStrandsVectorGroup[n].operator[](neighboridx).getSmoothCoordinate()[0]+ingredients.getTranslationInX();
							//float y_draw_mono_nn = linearStrandsVectorGroup[n].operator[](neighboridx).getSmoothCoordinate()[1]+ingredients.getTranslationInY();
							//float z_draw_mono_nn = linearStrandsVectorGroup[n].operator[](neighboridx).getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

							float x_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
							float y_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
							float z_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();



							glBegin(GL_LINES);						// draw bond
							glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
							glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
							glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
							glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
							glEnd();
																						}
						}


					}

			}

			}
		}


	}
	else {}


}


#endif /* LEMONADE_VIEWER_OPENGL_H */
