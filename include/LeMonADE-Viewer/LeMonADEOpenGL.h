/*--------------------------------------------------------------------------------
 _______________
|   /       \   | L   attice-based  | LeMonADE-Viewer:
|  /   ooo   \  | e   xtensible     | ----------------
| /  o\.|./o  \ | Mon te-Carlo      | An Open Source Visualization Tool for
|/  o\.\|/./o  \| A   lgorithm and  | for BFM-files generated by LeMonADE-software.
|  oo---0---oo  | D   evelopment    | See: https://github.com/LeMonADE-project/LeMonADE
|\  o/./|\.\o  /| E   nvironment    |
| \  o/.|.\o  / | -                 |
|  \   ooo   /  | Viewer            | Copyright (C) 2013-2015 by
|___\_______/___|                   | LeMonADE-Viewer Principal Developers (see AUTHORS)
----------------------------------------------------------------------------------

This file is part of LeMonADE-Viewer.

LeMonADE-Viewer is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE-Viewer is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE-Viewer.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#ifndef LEMONADE_VIEWER_OPENGL_H
#define LEMONADE_VIEWER_OPENGL_H

#include <FL/Fl.H>
#include <FL/Fl_Gl_Window.H>
#include <FL/gl.h>

#include <vector>

#include <LeMonADE/utility/DepthIterator.h>
#include <LeMonADE/utility/MonomerGroup.h>

#include <LeMonADE-Viewer/Camera.h>

// struct for emulate new and last mouse position
typedef struct {
  int button;
  int x;
  int y;
  int xold;
  int yold;
} Mouse;


template <class IngredientsType>
class LeMonADEOpenGL : public Fl_Gl_Window {

	// draw the scene
	void draw();

	// handle the user input (mouse+keyboard)
	int handle(int);

	// camera (position, yaw, pitch etc.)
	Camera cam;

	// reference to the data
	IngredientsType& ingredients;
	const typename IngredientsType::molecules_type& molecules;

	// abbreviation of ingredients.getBox()
	int boxX;
	int boxY;
	int boxZ;

	Mouse mouse;    // Keeping track of mouse input

	//find connected molecules and put them in group
	typedef std::vector < MonomerGroup<typename IngredientsType::molecules_type> > MonomerGroupVector;

	MonomerGroupVector& linearStrandsVectorGroup;

	void draw_coordinate_system();
	void draw_monomers();
	void draw_bonds();

	// helper array for interpolating monomers as spheres
	float xSphere1[256]; // subdivision between s is element [1,15]
	float ySphere1[256]; // indexing lat+longs*(s+1)
	float zSphere1[256];

	float xSphere2[256];
	float ySphere2[256];
	float zSphere2[256];



public:
	LeMonADEOpenGL(IngredientsType& _ingredients, MonomerGroupVector& _linearStrandsVectorGroup, int x,int y,int w,int h,const char *l=0): ingredients(_ingredients), linearStrandsVectorGroup(_linearStrandsVectorGroup),molecules(_ingredients.getMolecules()),Fl_Gl_Window(x,y,w,h,l)
{
		ingredients.setVisualizeBonds(true);
		ingredients.setVisualizePBC(false);
		ingredients.setWidthBond(0.3);
};

	virtual ~LeMonADEOpenGL(){};

	void initialize();

	void generatePovRayScript(std::string croppedFilenamePovray);

	// modulo operation for float numbers
	float mod(float a, float N) {return a - N*floor(a/N);}

	// interpolation of sphere
	// maybe we should use GLUT for that
	void precalculateSphere(int lats, int longs) {
		int i, j;

		int offset = ingredients.getSubdivisionSpheres()+1;

		int p = ingredients.getSubdivisionSpheres();
		int q = ingredients.getSubdivisionSpheres();

		int subdivision= ingredients.getSubdivisionSpheres();
		float PI=3.14159265f;
		//lat
		for(int i = 0; i < subdivision; i++)
		{
			//longs
			for(int j = 0; j <= subdivision; j++)
			{
				xSphere1[j+i*offset]=cos( (-0.5+(float)(i+1)/q)* PI ) * cos( 2.0 * (float)j/p * PI );
				ySphere1[j+i*offset]=cos( (-0.5+(float)(i+1)/q)* PI ) * sin( 2.0 * (float)j/p * PI );
				zSphere1[j+i*offset]=sin( (-0.5+(float)(i+1)/q)* PI );

				xSphere2[j+i*offset]=cos( (-0.5+(float)(i)/q)* PI ) * cos( 2.0 * (float)j/p * PI );
				ySphere2[j+i*offset]=cos( (-0.5+(float)(i)/q)* PI ) * sin( 2.0 * (float)j/p * PI );
				zSphere2[j+i*offset]=sin( (-0.5+(float)(i)/q)* PI );

			}
		}
	}
};

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::generatePovRayScript(std::string croppedFilenamePovray){

    std::ofstream afile;
	std::string afileName = croppedFilenamePovray+".pov";
	afile.open(afileName.c_str(),std::ios::trunc);

	afile << "// povray +I"<<croppedFilenamePovray << ".pov +O"<<croppedFilenamePovray << ".png +W"<<this->w() <<" +H" << this->h() << " +P " << std::endl;
	afile << "// +UA for transparency mask" << std::endl;
	afile << "" << std::endl;
	afile << "#version 3.5;" << std::endl << std::endl;
	afile << "#include "<< "\"" << "colors.inc" << "\"" << std::endl;
	afile << "" << std::endl;
	afile << "global_settings {assumed_gamma 1.0 noise_generator 2}" << std::endl;
	afile << "" << std::endl;

	// camera
	afile << "camera{" << std::endl;
	float radius = 1.5*boxZ;

	float pi = atan(1)*4;
	float PhiPov = (-cam.getCamAngleYaw()) * pi / 180.0;
	float ThetaPov1 = (-cam.getCamAnglePitch()) * pi / 180.0;
	float ThetaPov2 = (cam.getCamAnglePitch()) * pi / 180.0;

	// need clauses if position of camera is positive
	if((-cam.getCamYPos()) >=0)
	{	afile << "location <" << 0 << " , " << 0 << " , " << -cam.getCamYPos() << " > " << std::endl;

    afile << " right -x*" << this->w() << "/" << this->h()<<std::endl;
    afile << " look_at <0.0, 0.0, 0.0>" << std::endl;
    afile << " translate <" << cam.getCamXPos() << ", " << -cam.getCamZPos() << ", " << 0.0 << ">" << std::endl;
	}
	else
		{	afile << "location <" << 0 << " , " << 0 << " , " << 0 << " > " << std::endl;

		    afile << " right -x*" << this->w() << "/" << this->h()<<std::endl;
		    afile << " look_at <0.0, 0.0, " << (-cam.getCamYPos()) <<">" << std::endl;
		    afile << " translate <" << cam.getCamXPos() << ", " << -cam.getCamZPos() << ", " << 0.0 << ">" << std::endl;
			}

	double aspectRatio = (this->w() > this->h())? float(this->w())/float(this->h()) : float(this->h())/float(this->w());
	double fovy = 45.0; //degrees - fov is in y in openGL, povRay uses in x
	double anglefovx = 2 * atan ( ((1.0*this->w())/this->h()) * tan(fovy/2.0/180*3.1416) )* 180.0/3.1416;
	afile << " angle " << anglefovx<< std::endl;

	afile << "rotate  < 90, 0, 0 >" << std::endl;

		afile << "rotate  < 0, 0, " << -cam.getCamAngleYaw() << " >" << std::endl;
		//afile << "rotate  <" << -cam.getCamThetaRot() << ", 0 , 0 > "<< std::endl;
		afile << "rotate  <" << cam.getCamAnglePitch() << ", 0 , 0 > "<< std::endl;

		afile << " translate <" << 0.5*boxX  <<" , " << 0.5*boxY <<" , " << 0.5*boxZ << ">" << std::endl;

		afile << "}" << std::endl;

	afile << "" << std::endl;
	afile << "// background color" << std::endl;
	afile << "sky_sphere{pigment{color rgb< " << ingredients.getBGcolor()[0] << ", " << ingredients.getBGcolor()[1] << ", " << ingredients.getBGcolor()[2] << "> }}" << std::endl;
	afile << "" << std::endl;
	afile << "// light source" << std::endl;
	afile << "light_source{<1000.0, 1000.0, -200.0> color White}" << std::endl;

	afile << "light_source{< " << cam.getCamXPos() << " , " << -cam.getCamZPos() << " , " << -cam.getCamYPos() << " > color White"<< std::endl;
	//afile << "fade_distance " << -(cam.getCamYPos()+0.5*boxY) << std::endl;
	afile << "//fade_distance " << 100 << std::endl;
	afile << "//fade_power 3" << std::endl;
	afile << "rotate  < 90, 0, 0 >" << std::endl;

		afile << "rotate  < 0, 0, " << -cam.getCamAngleYaw() << " >" << std::endl;
		//afile << "rotate  <" << -cam.getCamThetaRot() << ", 0 , 0 > "<< std::endl;
		afile << "rotate  <" << cam.getCamAnglePitch() << ", 0 , 0 > "<< std::endl;

		afile << "translate <" << 0.5*boxX  <<" , " << 0.5*boxY <<" , " << 0.5*boxZ << ">" << std::endl;

	//afile << "rotate  < -90, 0, 0 >" << std::std::endl;
	//	afile << "rotate  < 0, 0, " << -cam.getCamPhiRot() << " >" << std::std::endl;
		//afile << "rotate  <" <<cam.getCamThetaRot()* cam.getCamThetaRotAxisX()<< ", 0 , " << cam.getCamThetaRot()*cam.getCamThetaRotAxisZ() << "  > "<< std::std::endl;
	//	afile << "rotate  <" << -cam.getCamThetaRot() << ", 0 , 0 > "<< std::std::endl;
	//	afile << " translate <" << 0.5*boxX  <<" , " << 0.5*boxY <<" , " << -0.5*boxZ << ">" << std::endl;
	afile << "}" << std::endl;

	afile << "" << std::endl;
	afile << "// objects (monomers)  " << std::endl;

	// das ist jetzt die reale monomer-Position (STIMMT DAS SCHON SO?)
	for(size_t n=0; n< molecules.size(); ++n){
	    	  if(molecules[n].isVisible())
	    	  {
	    		  if (ingredients.isSmoothing() == false){

	    			  if (ingredients.isVisualizePBC() == true) {
	    				  afile << "sphere{< " << ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX)  << ", " << ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY)  << ", " << (((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ) )  << "> " << molecules[n].getRadius() << std::endl;

	    			  }
	    			  else
	    			  	  //afile << "sphere{< " << linearStrandsVector[n].operator[](m)[0] - 0.5*boxX << ", " << linearStrandsVector[n].operator[](m)[1] - 0.5*boxX << ", " << -linearStrandsVector[n].operator[](m)[2] + 0.5 * boxZ << "> 2" << std::endl;
	    			  afile << "sphere{< " << (molecules[n][0]+ingredients.getTranslationInX())  << ", " << (molecules[n][1]+ingredients.getTranslationInY()) << ", " << (molecules[n][2]+ingredients.getTranslationInZ())  << "> " << (molecules[n].getRadius()) << std::endl;
	    		  }
	    		  else
	    		  {
	    			  if (ingredients.isVisualizePBC() == true) {
	    				  afile << "sphere{< " << ((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX)  ) )  << ", " << ((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) ) )  << ", " << (((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) ) ))  << "> " << (molecules[n].getRadius()) << std::endl;

	    			  }
	    			  else
	    			  afile << "sphere{< " << (molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX())  << ", " << (molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY())  << ", " << (molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ())  << "> " << (molecules[n].getRadius()) << std::endl;
	    		  }
		afile << " pigment {color rgb<" << molecules[n].getColor().getX() << ", " << molecules[n].getColor().getY() << ", " << molecules[n].getColor().getZ() <<  ">}" << std::endl;
		afile << " finish {phong 5.0 phong_size 40 reflection rgb<0.0, 0.0, 0.0> roughness 0.05 ambient 0.1 diffuse 0.9} }" << std::endl;

	      }

	}
	afile << std::endl;

	//bonds:

	if (ingredients.isVisualizeBonds() == true) {
		for(size_t n=0; n< molecules.size(); ++n){

	    	  size_t linkcount = ingredients.getMolecules().getNumLinks(n);		// check for the number of links the current monomer has

	    	  if(molecules[n].isVisible())
	    	  {
	    		  for(size_t k=0; k < linkcount; ++k)
	    			  {		  size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, k); 	// search for the monomers connected to the current

	    			  //draw only one bond
	    			  if(neighboridx < n)
	    			  {
	    		  if (ingredients.isSmoothing() == false)
	    		  {
	    		 	    //afile << "sphere{< " << linearStrandsVector[n].operator[](m)[0] - 0.5*boxX << ", " << linearStrandsVector[n].operator[](m)[1] - 0.5*boxX << ", " << -linearStrandsVector[n].operator[](m)[2] + 0.5 * boxZ << "> 2" << std::endl;
	    		 	   // afile << "sphere{< " << linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << "> " << (point_size/10.0f) << std::endl;
                       VectorFloat3 bondDirection;
                       bondDirection.setX(1.0f*(molecules[n][0]-ingredients.getMolecules()[neighboridx][0]));
                       bondDirection.setY(1.0f*(molecules[n][1]-ingredients.getMolecules()[neighboridx][1]));
                       bondDirection.setZ(1.0f*(molecules[n][2]-ingredients.getMolecules()[neighboridx][2]));

                       float bondLength= bondDirection.getLength();

                       if((bondLength>0.1) && (bondLength<6.0))
                       {
                      // bondDirection.normalize();

	    		 	   //afile << "cylinder{ < " << linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    		 	   afile << "cylinder{ <0,0,0> " << //linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    		 			    ", <" <<(-bondDirection[0]) << "," << -(bondDirection[1]) <<"," << -(bondDirection[2]) << ">, "  << ingredients.getWidthBond() <<
	    		 			  // ingredients.getMolecules()[neighboridx][0]  << ", " << ingredients.getMolecules()[neighboridx][1]  << ", " << (-ingredients.getMolecules()[neighboridx][2])  << "> "  <<
	    		 			 "  texture{ pigment{ gradient <"<< bondDirection[0]/bondDirection.getLength() <<"," << bondDirection[1]/bondDirection.getLength() <<"," << (bondDirection[2]/bondDirection.getLength()) <<
	    		 			 "> color_map{ [0.0 color rgb<" << ingredients.getMolecules()[neighboridx].getColor().getX() << ", " << ingredients.getMolecules()[neighboridx].getColor().getY() << ", " << ingredients.getMolecules()[neighboridx].getColor().getZ() <<  "> ]" <<
	    		 			 "[1.0 color rgb<" << molecules[n].getColor().getX() << ", " << molecules[n].getColor().getY() << ", " << molecules[n].getColor().getZ() <<  "> ]} scale "<< bondLength<<
	    		 			 " translate <" << (-bondDirection[0]) <<"," << -(bondDirection[1]) <<"," << -(bondDirection[2]) <<">} finish { phong 1}} translate < ";
	    		 			//ingredients.getMolecules()[neighboridx][0]  << ", " << ingredients.getMolecules()[neighboridx][1]  << ", " << (-ingredients.getMolecules()[neighboridx][2])  << "> "  <<

	    		 	   if(ingredients.isVisualizePBC() == false)
	    		 	   {
	    		 		   afile << (molecules[n][0]+ingredients.getTranslationInX())  << ", " << (molecules[n][1]+ingredients.getTranslationInY())  << ", " << (molecules[n][2]+ingredients.getTranslationInZ())  << ">";
	    		 	   }
	    		 	   else
	    		 	   {
	    		 		   afile << ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX) << ", " << ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY)  << ", " << ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ)  << ">";
	    		 	   }

	    		 	   afile << "scale <1,1,1> rotate<0,0,0> translate<0,0,0> }" <<std::endl;

                       }


	    		  }
	    		  else //smoothing true
		    		  {
	    			                   VectorFloat3 bondDirection;
	    			                        bondDirection.setX(1.0f*(molecules[n].getSmoothCoordinate()[0]-ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]));
	    			                        bondDirection.setY(1.0f*(molecules[n].getSmoothCoordinate()[1]-ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]));
	    			                        bondDirection.setZ(1.0f*(molecules[n].getSmoothCoordinate()[2]-ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]));

	    			                        float bondLength= bondDirection.getLength();

	    			                                               if((bondLength>0.1) && (bondLength<6.0))
	    			                                               {
	    			 	    		 	   //afile << "cylinder{ < " << linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    			 	    		 	   afile << "cylinder{ <0,0,0> " << //linearStrandsVectorGroup[n].operator[](m)[0]  << ", " << linearStrandsVectorGroup[n].operator[](m)[1]  << ", " << (-linearStrandsVectorGroup[n].operator[](m)[2])  << ">, <" <<
	    			 	    		 			    ", <" <<(-bondDirection[0]) << "," << -(bondDirection[1]) <<"," << -(bondDirection[2]) << ">, "  << ingredients.getWidthBond() <<
	    			 	    		 			  // ingredients.getMolecules()[neighboridx][0]  << ", " << ingredients.getMolecules()[neighboridx][1]  << ", " << (-ingredients.getMolecules()[neighboridx][2])  << "> "  <<
	    			 	    		 			 "  texture{ pigment{ gradient <"<< bondDirection[0]/bondDirection.getLength() <<"," << bondDirection[1]/bondDirection.getLength() <<"," << (bondDirection[2]/bondDirection.getLength()) <<
	    			 	    		 			 "> color_map{ [0.0 color rgb<" << ingredients.getMolecules()[neighboridx].getColor().getX() << ", " << ingredients.getMolecules()[neighboridx].getColor().getY() << ", " << ingredients.getMolecules()[neighboridx].getColor().getZ() <<  "> ]" <<
	    			 	    		 			 "[1.0 color rgb<" << molecules[n].getColor().getX() << ", " << molecules[n].getColor().getY() << ", " << molecules[n].getColor().getZ() <<  "> ]} scale "<< bondLength<<
	    			 	    		 			 " translate <" << (-bondDirection[0]) <<"," << -(bondDirection[1]) <<"," << -(bondDirection[2]) <<">} finish { phong 1}} translate < ";

	    			 	    		 	 if(ingredients.isVisualizePBC() == false)
	    			 	    		 	 	{
	    			 	    		 	 	    afile << (molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX())  << ", " << (molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY())  << ", " << (molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ())  << ">";
	    			 	    		 	 	}
	    			 	    		 	else
	    			 	    		 	 	 {
	    			 	    		 	 	    afile << mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX) << ", " << mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY)  << ", " << mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ)  << ">";
	    			 	    		 	 	 }

	    			 	    		 	afile << "scale <1,1,1> rotate<0,0,0> translate<0,0,0> }" <<std::endl;
	    			                                               }

		    		 	 }
	    			  }

	    		  }
	    			  }

	      }
	}






	afile << "" << std::endl;
	// BOND VECTORS EINBINDEN!!!
	afile.close();


}


template <class IngredientsType>
int LeMonADEOpenGL<IngredientsType>::handle(int e) {

	int delta_x=0, delta_y=0;

	switch (e) {
	case FL_ENTER: cursor(FL_CURSOR_CROSS); break;
	case FL_LEAVE: cursor(FL_CURSOR_DEFAULT); break;

	case FL_MOUSEWHEEL:
		cam.setHoldingForwardMouse(Fl::event_dy());
		break;

	case FL_RELEASE:

		mouse.x = (Fl::event_x());
		mouse.y = (Fl::event_y());
		mouse.button = 0;
		break;

	case FL_PUSH:
		cam.setCamAngleYawSpeed(0.0);
		cam.setCamAnglePitchSpeed(0.0);

		mouse.x = (Fl::event_x());
		mouse.y = (Fl::event_y());
		mouse.button = (Fl::event_button());
		break;

	case FL_DRAG: if(Fl::event_button1())
	{
		mouse.x=Fl::event_x();
		mouse.y=Fl::event_y();
		delta_x=mouse.x-mouse.xold;
		delta_y=mouse.y-mouse.yold;

		cam.handleMouseMove(delta_x, delta_y, boxX, boxY, boxZ);
		redraw();
	}

	break;

	case FL_KEYDOWN:

		if (int(Fl::event_key()) == int('i'))
		{cam.setHoldingForwardI(true);}

		if (int(Fl::event_key()) == int('o'))
		{cam.setHoldingBackwardO(true);}

		if (int(Fl::event_key()) == int('w'))
		{cam.setHoldingUpW(true);}

		if (int(Fl::event_key()) == int('s'))
		{cam.setHoldingDownS(true);}

		if (int(Fl::event_key()) == int('a'))
		{cam.setHoldingLeftA(true);}

		if (int(Fl::event_key()) == int('d'))
		{cam.setHoldingRightD(true);}

		if (int(Fl::event_key()) == int('r')) //resets camera
		{
			//Camera rotation
			cam.setCamAngleYaw(0.0f);
			cam.setCamAnglePitch(0.0f);

			cam.setCamAngleYawSpeed(0.0f);
			cam.setCamAnglePitchSpeed(0.0f);

			// Camera position
			cam.setCamXPos(0.0f);
			cam.setCamYPos(-2*this->ingredients.getBoxY());
			cam.setCamZPos(0.0f);
		}
		break;

	case FL_KEYUP:

		if (int(Fl::event_key()) == int('i'))
		{cam.setHoldingForwardI(false);}

		if (int(Fl::event_key()) == int('o'))
		{cam.setHoldingBackwardO(false);}

		if (int(Fl::event_key()) == int('w'))
		{cam.setHoldingUpW(false);}

		if (int(Fl::event_key()) == int('s'))
		{cam.setHoldingDownS(false);}

		if (int(Fl::event_key()) == int('a'))
		{cam.setHoldingLeftA(false);}

		if (int(Fl::event_key()) == int('d'))
		{cam.setHoldingRightD(false);}


		break;
	}



	mouse.xold=mouse.x;
	mouse.yold=mouse.y;

	return Fl_Gl_Window::handle(e);
}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::initialize(){


	//cam.setCamZPos(2*this->ingredients.getBoxZ());
	cam.setCamYPos(-2*this->ingredients.getBoxY());

	boxX = this->ingredients.getBoxX();
	boxY = this->ingredients.getBoxY();
	boxZ = this->ingredients.getBoxZ();

	// in the first frame we color all monomer from red to blue
	/*
	 	 	for(size_t n=0; n< linearStrandsVectorGroup.size(); ++n){
		 		  float colorvar = 1./(linearStrandsVectorGroup.size())*n;

		 		  for(size_t m=0; m< linearStrandsVectorGroup[n].size(); ++m){

		 			 ingredients.modifyMolecules()[linearStrandsVectorGroup[n].trueIndex(m)].setColor(colorvar, 0, 1-colorvar);



		 		  }
		 		}
	 */

	for(size_t n=0; n< molecules.size(); ++n){
		float colorvar = 1./(molecules.size())*n;
		ingredients.modifyMolecules()[n].setColor(colorvar, 0, 1-colorvar);

	}

	precalculateSphere(ingredients.getSubdivisionSpheres(),ingredients.getSubdivisionSpheres());

}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw(){

	// maybe the window has resized or similar
	if (!valid()) {

		glLoadIdentity();

		// background color
		glClearColor(ingredients.getBGcolor()[0], ingredients.getBGcolor()[1], ingredients.getBGcolor()[2], 0.0f);

		// color smoothing
		glShadeModel(GL_SMOOTH);

		// Enable depth testing
		glEnable(GL_DEPTH_TEST);

	    // Clear the entire depth of the depth buffer
		glClearDepth(1.0f);

		// Set our depth function to overwrite if new value less than or equal to current value
		glDepthFunc(GL_LEQUAL);

		// Ask for nicest perspective correction
		glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);


		GLint windowWidth = this->w();
		GLint windowHeight = this->h();

		GLfloat fieldOfView = 45.0f;  // Define our field of view (i.e. how quickly foreshortening occurs)
		GLfloat near        = 1.0f;   // The near (Z Axis) point of our viewing frustrum (default 1.0f)
		GLfloat far         = 1500.0f;// The far  (Z Axis) point of our viewing frustrum (default 1500.0f)

		// Setup our viewport to be the entire size of the window
		glViewport(0, 0, (GLsizei)windowWidth, (GLsizei)windowHeight);

		// Change to the projection matrix, reset the matrix and set up our projection
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();

		// http://nehe.gamedev.net/article/replacement_for_gluperspective/21002/
		// The following code is a fancy bit of math that is eqivilant to calling:
		// gluPerspective(fieldOfView/2.0f, width/height , near, far);
		// We do it this way simply to avoid requiring glu.h
		GLfloat aspectRatio = (windowWidth > windowHeight)? float(windowWidth)/float(windowHeight) : float(windowHeight)/float(windowWidth);
		GLfloat fH = tan( float(fieldOfView / 360.0f * 3.14159f) ) * near;
		GLfloat fW = fH * aspectRatio;

		glFrustum(-fW, fW, -fH, fH, near, far);

		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();



	}
	// Clear the screen and depth buffer
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glClearColor(ingredients.getBGcolor()[0], ingredients.getBGcolor()[1], ingredients.getBGcolor()[2], 0.0f); // color background

	// Reset the matrix
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	// Move the simulation box to the right position in space
	glTranslatef(-cam.getCamXPos(),cam.getCamZPos(),cam.getCamYPos());

	glRotatef(-90.0, 1.0f, 0.0f, 0.0f);
	//Rotate the simulation box accordingly to the calculated "camera rotation" angles
	//Rotation around center of the simulation box
	glRotatef(cam.getCamAngleYaw(), 0.0f, 0.0f, 1.0f);
	glRotatef(-cam.getCamAnglePitch(), 1.0f, 0.0f, 0.0f);
	//glRotatef(cam.getCamThetaRot(), -cam.getCamThetaRotAxisX(), 0.0f, -cam.getCamThetaRotAxisZ());
	//move the simulation box with the center into the origin of coordinates
	glTranslatef(-0.5*boxX, -0.5*boxY, -0.5*boxZ);


	// draw the scene
	draw_coordinate_system();
	draw_monomers();
	draw_bonds();

	// rotate or move the camera between input and frame delay
	cam.calculateCameraMovement();

	// Move our camera
	cam.moveCamera();


}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw_coordinate_system()
{
	glLineWidth(2.0);

	// drawing the horizontal edges of the box
	glBegin(GL_LINE_LOOP);
	glColor3f(1, 1, 1);
	glVertex3f(0, 0, 0);
	glVertex3f(0, 0, boxZ);
	glVertex3f(boxX, 0, boxZ);
	glVertex3f(boxX, 0, 0);
	glEnd();

	glBegin(GL_LINE_LOOP);
	glVertex3f(0, boxY, 0);
	glVertex3f(0, boxY, boxZ);
	glVertex3f(boxX, boxY, boxZ);
	glVertex3f(boxX, boxY, 0);
	glEnd();

	// drawing the vertical edges of the box
	glBegin(GL_LINES);
	glVertex3f(0, 0, 0);
	glVertex3f(0, boxY, 0);
	glVertex3f(0, 0, boxZ);
	glVertex3f(0, boxY, boxZ);
	glVertex3f(boxX, 0, boxZ);
	glVertex3f(boxX, boxY, boxZ);
	glVertex3f(boxX, 0, 0);
	glVertex3f(boxX, boxY, 0);
	glEnd();

	// drawing a single square in one corner of the box (for scale/size comparison)
	glBegin(GL_QUADS);
	glVertex3f(-0.5, -0.5, boxZ);
	glVertex3f(+0.5, -0.5, boxZ);
	glVertex3f(+0.5, +0.5, boxZ);
	glVertex3f(-0.5, +0.5, boxZ);
	glEnd();

	// drawing coordinate system in the origin
	glBegin(GL_LINES);
	glColor3f(1, 0, 0);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10+boxX, -10, -10);
	glColor3f(0, 1, 0);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10, -10+boxY, -10);
	glColor3f(0, 0, 1);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10, -10, -10+boxZ);
	glEnd();

}

// todo: simplify this
template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw_monomers(){

	// drawing the monomers (represented by cubes) and sorted by groups (e.g. chains), which are represented by using different colors

	if (ingredients.isSmoothing() == false)
	{
		if (ingredients.isVisualizePBC() == true)
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
						float y_draw = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
						float z_draw = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
						float y_draw = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
						float z_draw = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);

						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset] + y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);
								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);
							}
							glEnd();
						}
					}
				}
			}
		}

		else
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n][0]+ingredients.getTranslationInX();
						float y_draw = molecules[n][1]+ingredients.getTranslationInY();
						float z_draw = molecules[n][2]+ingredients.getTranslationInZ();
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n][0]+ingredients.getTranslationInX();
						float y_draw = molecules[n][1]+ingredients.getTranslationInY();
						float z_draw = molecules[n][2]+ingredients.getTranslationInZ();

						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset]+ y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);

								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);

							}
							glEnd();
						}
					}
				}
			}
		}
	}
	//smoothing here
	else
	{
		if (ingredients.isVisualizePBC() == true)
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
						float y_draw = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
						float z_draw = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						//glColor3f(colorvar, 0, 1-colorvar);
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
						float y_draw = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
						float z_draw = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);
						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset] + y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);
								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);
							}
							glEnd();
						}
					}
				}
			}
		}
		else
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
						float y_draw = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
						float z_draw = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						//glColor3f(colorvar, 0, 1-colorvar);
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
						float y_draw = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
						float z_draw = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset] + y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);
								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);
							}
							glEnd();
						}
					}
				}
			}
		}
	}
}

// todo: simplify this
template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw_bonds()
{

	if (ingredients.isVisualizeBonds() == true)
	{
		if (ingredients.isSmoothing() == false)
		{
			if (ingredients.isVisualizePBC() == true)
			{
				glLineWidth(ingredients.getWidthBond()*10);

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
						float y_draw_mono_orig = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
						float z_draw_mono_orig = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);


						for(size_t nn=0; nn < linkcount; ++nn){

							//size_t neighboridx = linearStrandsVectorGroup[n].copyGroup().getNeighborIdx(m, nn); 	// search for the monomers connected to the current
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{
								float x_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
								float y_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
								float z_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);

								if((x_draw_mono_orig-x_draw_mono_nn)*(x_draw_mono_orig-x_draw_mono_nn)+(y_draw_mono_orig-y_draw_mono_nn)*(y_draw_mono_orig-y_draw_mono_nn)+(z_draw_mono_orig-z_draw_mono_nn)*(z_draw_mono_orig-z_draw_mono_nn) <= 20)
								{
									glBegin(GL_LINES);						// draw bond
									glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
									glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
									glEnd();
								}
							}
						}
					}
				}
			}
			else
			{
				glLineWidth(ingredients.getWidthBond()*10);

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = (molecules[n][0]+ingredients.getTranslationInX());
						float y_draw_mono_orig = (molecules[n][1]+ingredients.getTranslationInY());
						float z_draw_mono_orig = (molecules[n][2]+ingredients.getTranslationInZ());

						for(size_t nn=0; nn < linkcount; ++nn){

							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{
								float x_draw_mono_nn = ingredients.getMolecules()[neighboridx][0]+ingredients.getTranslationInX();
								float y_draw_mono_nn = ingredients.getMolecules()[neighboridx][1]+ingredients.getTranslationInY();
								float z_draw_mono_nn = ingredients.getMolecules()[neighboridx][2]+ingredients.getTranslationInZ();

								glBegin(GL_LINES);						// draw bond
								glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
								glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
								glEnd();
							}
						}
					}
				}
			}
		}
		else // smoothing true
		{
			if (ingredients.isVisualizePBC() == true)
			{
				glLineWidth(ingredients.getWidthBond()*10);
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
						float y_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
						float z_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);

						for(size_t nn=0; nn < linkcount; ++nn)
						{
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{

								float x_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
								float y_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
								float z_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);

								if((x_draw_mono_orig-x_draw_mono_nn)*(x_draw_mono_orig-x_draw_mono_nn)+(y_draw_mono_orig-y_draw_mono_nn)*(y_draw_mono_orig-y_draw_mono_nn)+(z_draw_mono_orig-z_draw_mono_nn)*(z_draw_mono_orig-z_draw_mono_nn) <= 20)
								{
									glBegin(GL_LINES);						// draw bond
									glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
									glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
									glEnd();
								}
							}
						}
					}
				}
			}
			else
			{
				glLineWidth(ingredients.getWidthBond()*10);

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
						float y_draw_mono_orig = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
						float z_draw_mono_orig = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

						for(size_t nn=0; nn < linkcount; ++nn){
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{
								float x_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
								float y_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
								float z_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

								glBegin(GL_LINES);						// draw bond
								glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
								glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
								glEnd();
							}
						}
					}
				}
			}
		}
	}
	else
	{ // nothing to do instead

	}
}

#endif /* LEMONADE_VIEWER_OPENGL_H */
