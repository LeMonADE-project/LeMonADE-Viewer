/*--------------------------------------------------------------------------------
 _______________
|   /       \   | L   attice-based  | LeMonADE-Viewer:
|  /   ooo   \  | e   xtensible     | ----------------
| /  o\.|./o  \ | Mon te-Carlo      | An Open Source Visualization Tool for
|/  o\.\|/./o  \| A   lgorithm and  | for BFM-files generated by LeMonADE-software.
|  oo---0---oo  | D   evelopment    | See: https://github.com/LeMonADE-project/LeMonADE
|\  o/./|\.\o  /| E   nvironment    |
| \  o/.|.\o  / | -                 |
|  \   ooo   /  | Viewer            | Copyright (C) 2013-2015 by
|___\_______/___|                   | LeMonADE-Viewer Principal Developers (see AUTHORS)
----------------------------------------------------------------------------------

This file is part of LeMonADE-Viewer.

LeMonADE-Viewer is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE-Viewer is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE-Viewer.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#pragma once

#include <FL/Fl.H>
#include <FL/Fl_Gl_Window.H>
#include <FL/gl.h>

#include <vector>

#include <LeMonADE/utility/DepthIterator.h>
#include <LeMonADE/utility/MonomerGroup.h>

#include "LeMonADE-Viewer/Camera.h"
#include "generatePovRayScript.h"



// struct for emulate new and last mouse position
typedef struct {
  int button;
  int x;
  int y;
  int xold;
  int yold;
} Mouse;


template <class IngredientsType>
class LeMonADEOpenGL : public Fl_Gl_Window {

	// draw the scene
	void draw();

	// handle the user input (mouse+keyboard)
	int handle(int);

	// camera (position, yaw, pitch etc.)
	Camera cam;

	// reference to the data
	IngredientsType& ingredients;
	const typename IngredientsType::molecules_type& molecules;

	// abbreviation of ingredients.getBox()
	int boxX;
	int boxY;
	int boxZ;

	Mouse mouse;    // Keeping track of mouse input

	//find connected molecules and put them in group
	typedef std::vector < MonomerGroup<typename IngredientsType::molecules_type> > MonomerGroupVector;

	MonomerGroupVector& linearStrandsVectorGroup;

	void draw_coordinate_system();
	void draw_monomers();
	void draw_bonds();

	// helper array for interpolating monomers as spheres
	float xSphere1[256]; // subdivision between s is element [1,15]
	float ySphere1[256]; // indexing lat+longs*(s+1)
	float zSphere1[256];

	float xSphere2[256];
	float ySphere2[256];
	float zSphere2[256];



public:
	LeMonADEOpenGL(IngredientsType& _ingredients, MonomerGroupVector& _linearStrandsVectorGroup, int x,int y,int w,int h,const char *l=0): ingredients(_ingredients), linearStrandsVectorGroup(_linearStrandsVectorGroup),molecules(_ingredients.getMolecules()),Fl_Gl_Window(x,y,w,h,l)
{
		ingredients.setVisualizeBonds(true);
		ingredients.setVisualizePBC(false);
		ingredients.setWidthBond(0.3);
};

    inline Camera & modifyCamera( void ){ return cam; }
    inline Camera const & getCamera( void ) const { return cam; }

	virtual ~LeMonADEOpenGL(){};

	void initialize();

	void generatePovRayScript( std::string const & croppedFilenamePovray );

	// modulo operation for float numbers
	float mod(float a, float N) {return a - N*floor(a/N);}

	// interpolation of sphere
	// maybe we should use GLUT for that
	void precalculateSphere( int lats, int longs )
    {
		int i, j;

		int offset = ingredients.getSubdivisionSpheres()+1;

		int p = ingredients.getSubdivisionSpheres();
		int q = ingredients.getSubdivisionSpheres();

		int subdivision= ingredients.getSubdivisionSpheres();
		float PI=3.14159265f;
		//lat
		for(int i = 0; i < subdivision; i++)
		{
			//longs
			for(int j = 0; j <= subdivision; j++)
			{
				xSphere1[j+i*offset]=cos( (-0.5+(float)(i+1)/q)* PI ) * cos( 2.0 * (float)j/p * PI );
				ySphere1[j+i*offset]=cos( (-0.5+(float)(i+1)/q)* PI ) * sin( 2.0 * (float)j/p * PI );
				zSphere1[j+i*offset]=sin( (-0.5+(float)(i+1)/q)* PI );

				xSphere2[j+i*offset]=cos( (-0.5+(float)(i)/q)* PI ) * cos( 2.0 * (float)j/p * PI );
				ySphere2[j+i*offset]=cos( (-0.5+(float)(i)/q)* PI ) * sin( 2.0 * (float)j/p * PI );
				zSphere2[j+i*offset]=sin( (-0.5+(float)(i)/q)* PI );

			}
		}
	}
};


template < class IngredientsType >
void LeMonADEOpenGL< IngredientsType >::generatePovRayScript
(
    std::string const & croppedFilenamePovray
)
{
    ::generatePovRayScript( this->ingredients, croppedFilenamePovray, this->w(), this->h(), this->cam );
}


template <class IngredientsType>
int LeMonADEOpenGL<IngredientsType>::handle(int e) {

	int delta_x=0, delta_y=0;

	switch (e) {
	case FL_ENTER: cursor(FL_CURSOR_CROSS); break;
	case FL_LEAVE: cursor(FL_CURSOR_DEFAULT); break;

	case FL_MOUSEWHEEL:
		cam.setHoldingForwardMouse(Fl::event_dy());
		break;

	case FL_RELEASE:

		mouse.x = (Fl::event_x());
		mouse.y = (Fl::event_y());
		mouse.button = 0;
		break;

	case FL_PUSH:
		cam.setCamAngleYawSpeed(0.0);
		cam.setCamAnglePitchSpeed(0.0);

		mouse.x = (Fl::event_x());
		mouse.y = (Fl::event_y());
		mouse.button = (Fl::event_button());
		break;

	case FL_DRAG: if(Fl::event_button1())
	{
		mouse.x=Fl::event_x();
		mouse.y=Fl::event_y();
		delta_x=mouse.x-mouse.xold;
		delta_y=mouse.y-mouse.yold;

		cam.handleMouseMove(delta_x, delta_y, boxX, boxY, boxZ);
		redraw();
	}

	break;

	case FL_KEYDOWN:

		if (int(Fl::event_key()) == int('i'))
		{cam.setHoldingForwardI(true);}

		if (int(Fl::event_key()) == int('o'))
		{cam.setHoldingBackwardO(true);}

		if (int(Fl::event_key()) == int('w'))
		{cam.setHoldingUpW(true);}

		if (int(Fl::event_key()) == int('s'))
		{cam.setHoldingDownS(true);}

		if (int(Fl::event_key()) == int('a'))
		{cam.setHoldingLeftA(true);}

		if (int(Fl::event_key()) == int('d'))
		{cam.setHoldingRightD(true);}

		if (int(Fl::event_key()) == int('r')) //resets camera
		{
			//Camera rotation
			cam.setCamAngleYaw(0.0f);
			cam.setCamAnglePitch(0.0f);

			cam.setCamAngleYawSpeed(0.0f);
			cam.setCamAnglePitchSpeed(0.0f);

			// Camera position
			cam.setCamXPos(0.0f);
			cam.setCamYPos(-2*this->ingredients.getBoxY());
			cam.setCamZPos(0.0f);
		}
		break;

	case FL_KEYUP:

		if (int(Fl::event_key()) == int('i'))
		{cam.setHoldingForwardI(false);}

		if (int(Fl::event_key()) == int('o'))
		{cam.setHoldingBackwardO(false);}

		if (int(Fl::event_key()) == int('w'))
		{cam.setHoldingUpW(false);}

		if (int(Fl::event_key()) == int('s'))
		{cam.setHoldingDownS(false);}

		if (int(Fl::event_key()) == int('a'))
		{cam.setHoldingLeftA(false);}

		if (int(Fl::event_key()) == int('d'))
		{cam.setHoldingRightD(false);}


		break;
	}



	mouse.xold=mouse.x;
	mouse.yold=mouse.y;

	return Fl_Gl_Window::handle(e);
}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::initialize(){


	//cam.setCamZPos(2*this->ingredients.getBoxZ());
	cam.setCamYPos(-2*this->ingredients.getBoxY());

	boxX = this->ingredients.getBoxX();
	boxY = this->ingredients.getBoxY();
	boxZ = this->ingredients.getBoxZ();

	// in the first frame we color all monomer from red to blue
	/*
	 	 	for(size_t n=0; n< linearStrandsVectorGroup.size(); ++n){
		 		  float colorvar = 1./(linearStrandsVectorGroup.size())*n;

		 		  for(size_t m=0; m< linearStrandsVectorGroup[n].size(); ++m){

		 			 ingredients.modifyMolecules()[linearStrandsVectorGroup[n].trueIndex(m)].setColor(colorvar, 0, 1-colorvar);



		 		  }
		 		}
	 */

	for(size_t n=0; n< molecules.size(); ++n){
		float colorvar = 1./(molecules.size())*n;
		ingredients.modifyMolecules()[n].setColor(colorvar, 0, 1-colorvar);

	}

	precalculateSphere(ingredients.getSubdivisionSpheres(),ingredients.getSubdivisionSpheres());

}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw(){

	// maybe the window has resized or similar
	if (!valid()) {

		glLoadIdentity();

		// background color
		glClearColor(ingredients.getBGcolor()[0], ingredients.getBGcolor()[1], ingredients.getBGcolor()[2], 0.0f);

		// color smoothing
		glShadeModel(GL_SMOOTH);

		// Enable depth testing
		glEnable(GL_DEPTH_TEST);

	    // Clear the entire depth of the depth buffer
		glClearDepth(1.0f);

		// Set our depth function to overwrite if new value less than or equal to current value
		glDepthFunc(GL_LEQUAL);

		// Ask for nicest perspective correction
		glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);


		GLint windowWidth = this->w();
		GLint windowHeight = this->h();

		GLfloat fieldOfView = 45.0f;  // Define our field of view (i.e. how quickly foreshortening occurs)
		GLfloat near        = 1.0f;   // The near (Z Axis) point of our viewing frustrum (default 1.0f)
		GLfloat far         = 1500.0f;// The far  (Z Axis) point of our viewing frustrum (default 1500.0f)

		// Setup our viewport to be the entire size of the window
		glViewport(0, 0, (GLsizei)windowWidth, (GLsizei)windowHeight);

		// Change to the projection matrix, reset the matrix and set up our projection
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();

		// http://nehe.gamedev.net/article/replacement_for_gluperspective/21002/
		// The following code is a fancy bit of math that is eqivilant to calling:
		// gluPerspective(fieldOfView/2.0f, width/height , near, far);
		// We do it this way simply to avoid requiring glu.h
		GLfloat aspectRatio = (windowWidth > windowHeight)? float(windowWidth)/float(windowHeight) : float(windowHeight)/float(windowWidth);
		GLfloat fH = tan( float(fieldOfView / 360.0f * 3.14159f) ) * near;
		GLfloat fW = fH * aspectRatio;

		glFrustum(-fW, fW, -fH, fH, near, far);

		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();



	}
	// Clear the screen and depth buffer
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glClearColor(ingredients.getBGcolor()[0], ingredients.getBGcolor()[1], ingredients.getBGcolor()[2], 0.0f); // color background

	// Reset the matrix
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	// Move the simulation box to the right position in space
	glTranslatef(-cam.getCamXPos(),cam.getCamZPos(),cam.getCamYPos());

	glRotatef(-90.0, 1.0f, 0.0f, 0.0f);
	//Rotate the simulation box accordingly to the calculated "camera rotation" angles
	//Rotation around center of the simulation box
	glRotatef(cam.getCamAngleYaw(), 0.0f, 0.0f, 1.0f);
	glRotatef(-cam.getCamAnglePitch(), 1.0f, 0.0f, 0.0f);
	//glRotatef(cam.getCamThetaRot(), -cam.getCamThetaRotAxisX(), 0.0f, -cam.getCamThetaRotAxisZ());
	//move the simulation box with the center into the origin of coordinates
	glTranslatef(-0.5*boxX, -0.5*boxY, -0.5*boxZ);


	// draw the scene
	draw_coordinate_system();
	draw_monomers();
	draw_bonds();

	// rotate or move the camera between input and frame delay
	cam.calculateCameraMovement();

	// Move our camera
	cam.moveCamera();


}

template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw_coordinate_system()
{
	glLineWidth(2.0);

	// drawing the horizontal edges of the box
	glBegin(GL_LINE_LOOP);
	glColor3f(1, 1, 1);
	glVertex3f(0, 0, 0);
	glVertex3f(0, 0, boxZ);
	glVertex3f(boxX, 0, boxZ);
	glVertex3f(boxX, 0, 0);
	glEnd();

	glBegin(GL_LINE_LOOP);
	glVertex3f(0, boxY, 0);
	glVertex3f(0, boxY, boxZ);
	glVertex3f(boxX, boxY, boxZ);
	glVertex3f(boxX, boxY, 0);
	glEnd();

	// drawing the vertical edges of the box
	glBegin(GL_LINES);
	glVertex3f(0, 0, 0);
	glVertex3f(0, boxY, 0);
	glVertex3f(0, 0, boxZ);
	glVertex3f(0, boxY, boxZ);
	glVertex3f(boxX, 0, boxZ);
	glVertex3f(boxX, boxY, boxZ);
	glVertex3f(boxX, 0, 0);
	glVertex3f(boxX, boxY, 0);
	glEnd();

	// drawing a single square in one corner of the box (for scale/size comparison)
	glBegin(GL_QUADS);
	glVertex3f(-0.5, -0.5, boxZ);
	glVertex3f(+0.5, -0.5, boxZ);
	glVertex3f(+0.5, +0.5, boxZ);
	glVertex3f(-0.5, +0.5, boxZ);
	glEnd();

	// drawing coordinate system in the origin
	glBegin(GL_LINES);
	glColor3f(1, 0, 0);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10+boxX, -10, -10);
	glColor3f(0, 1, 0);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10, -10+boxY, -10);
	glColor3f(0, 0, 1);
	glVertex3f(-10, -10, -10);
	glVertex3f(-10, -10, -10+boxZ);
	glEnd();

}

// todo: simplify this
template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw_monomers(){

	// drawing the monomers (represented by cubes) and sorted by groups (e.g. chains), which are represented by using different colors

	if (ingredients.isSmoothing() == false)
	{
		if (ingredients.isVisualizePBC() == true)
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
						float y_draw = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
						float z_draw = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
						float y_draw = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
						float z_draw = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);

						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset] + y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);
								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);
							}
							glEnd();
						}
					}
				}
			}
		}

		else
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n][0]+ingredients.getTranslationInX();
						float y_draw = molecules[n][1]+ingredients.getTranslationInY();
						float z_draw = molecules[n][2]+ingredients.getTranslationInZ();
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n][0]+ingredients.getTranslationInX();
						float y_draw = molecules[n][1]+ingredients.getTranslationInY();
						float z_draw = molecules[n][2]+ingredients.getTranslationInZ();

						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset]+ y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);

								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);

							}
							glEnd();
						}
					}
				}
			}
		}
	}
	//smoothing here
	else
	{
		if (ingredients.isVisualizePBC() == true)
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
						float y_draw = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
						float z_draw = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						//glColor3f(colorvar, 0, 1-colorvar);
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
						float y_draw = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
						float z_draw = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);
						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset] + y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);
								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);
							}
							glEnd();
						}
					}
				}
			}
		}
		else
		{
			if (ingredients.isDrawingMonomersAsSpheres() == false)
			{
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
						float y_draw = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
						float z_draw = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();
						glPointSize(molecules[n].getRadius()*10.0f);
						glBegin(GL_POINTS);
						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						//glColor3f(colorvar, 0, 1-colorvar);
						glVertex3f(x_draw, y_draw, z_draw);
						glEnd();
					}
				}
			}
			else
			{
				const int subdivision = ingredients.getSubdivisionSpheres();
				const int subdivisionOffset = ingredients.getSubdivisionSpheres()+1;

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						float x_draw = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
						float y_draw = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
						float z_draw = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

						float radius = molecules[n].getRadius();

						glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());

						for(int lats = 0; lats < subdivision; lats++)
						{
							// One latitudinal triangle strip.
							glBegin(GL_TRIANGLE_STRIP);
							for(int longs = 0; longs <= subdivision; longs++)
							{
								glVertex3f(radius*xSphere1[longs+lats*subdivisionOffset] +x_draw, radius*ySphere1[longs+lats*subdivisionOffset] + y_draw, radius*zSphere1[longs+lats*subdivisionOffset] + z_draw);
								glVertex3f(radius*xSphere2[longs+lats*subdivisionOffset] +x_draw, radius*ySphere2[longs+lats*subdivisionOffset] + y_draw, radius*zSphere2[longs+lats*subdivisionOffset] + z_draw);
							}
							glEnd();
						}
					}
				}
			}
		}
	}
}

// todo: simplify this
template <class IngredientsType>
void LeMonADEOpenGL<IngredientsType>::draw_bonds()
{

	if (ingredients.isVisualizeBonds() == true)
	{
		if (ingredients.isSmoothing() == false)
		{
			if (ingredients.isVisualizePBC() == true)
			{
				glLineWidth(ingredients.getWidthBond()*10);

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = ((((molecules[n][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
						float y_draw_mono_orig = ((((molecules[n][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
						float z_draw_mono_orig = ((((molecules[n][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);


						for(size_t nn=0; nn < linkcount; ++nn){

							//size_t neighboridx = linearStrandsVectorGroup[n].copyGroup().getNeighborIdx(m, nn); 	// search for the monomers connected to the current
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{
								float x_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][0]+ingredients.getTranslationInX())% boxX) + boxX)%boxX);
								float y_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][1]+ingredients.getTranslationInY())% boxY) + boxY)%boxY);
								float z_draw_mono_nn = ((((ingredients.getMolecules()[neighboridx][2]+ingredients.getTranslationInZ())% boxZ) + boxZ)%boxZ);

								if((x_draw_mono_orig-x_draw_mono_nn)*(x_draw_mono_orig-x_draw_mono_nn)+(y_draw_mono_orig-y_draw_mono_nn)*(y_draw_mono_orig-y_draw_mono_nn)+(z_draw_mono_orig-z_draw_mono_nn)*(z_draw_mono_orig-z_draw_mono_nn) <= 20)
								{
									glBegin(GL_LINES);						// draw bond
									glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
									glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
									glEnd();
								}
							}
						}
					}
				}
			}
			else
			{
				glLineWidth(ingredients.getWidthBond()*10);

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						//size_t linkcount = linearStrandsVectorGroup[n].copyGroup().getNumLinks(m);	// check for the number of links the current monomer has
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = (molecules[n][0]+ingredients.getTranslationInX());
						float y_draw_mono_orig = (molecules[n][1]+ingredients.getTranslationInY());
						float z_draw_mono_orig = (molecules[n][2]+ingredients.getTranslationInZ());

						for(size_t nn=0; nn < linkcount; ++nn){

							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{
								float x_draw_mono_nn = ingredients.getMolecules()[neighboridx][0]+ingredients.getTranslationInX();
								float y_draw_mono_nn = ingredients.getMolecules()[neighboridx][1]+ingredients.getTranslationInY();
								float z_draw_mono_nn = ingredients.getMolecules()[neighboridx][2]+ingredients.getTranslationInZ();

								glBegin(GL_LINES);						// draw bond
								glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
								glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
								glEnd();
							}
						}
					}
				}
			}
		}
		else // smoothing true
		{
			if (ingredients.isVisualizePBC() == true)
			{
				glLineWidth(ingredients.getWidthBond()*10);
				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
						float y_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
						float z_draw_mono_orig = mod((mod(molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);

						for(size_t nn=0; nn < linkcount; ++nn)
						{
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{

								float x_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]+ingredients.getTranslationInX(), boxX) )+boxX, boxX);
								float y_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]+ingredients.getTranslationInY(), boxY) )+boxY, boxY);
								float z_draw_mono_nn = mod((mod(ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]+ingredients.getTranslationInZ(), boxZ) )+boxZ, boxZ);

								if((x_draw_mono_orig-x_draw_mono_nn)*(x_draw_mono_orig-x_draw_mono_nn)+(y_draw_mono_orig-y_draw_mono_nn)*(y_draw_mono_orig-y_draw_mono_nn)+(z_draw_mono_orig-z_draw_mono_nn)*(z_draw_mono_orig-z_draw_mono_nn) <= 20)
								{
									glBegin(GL_LINES);						// draw bond
									glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
									glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
									glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
									glEnd();
								}
							}
						}
					}
				}
			}
			else
			{
				glLineWidth(ingredients.getWidthBond()*10);

				for(size_t n=0; n< molecules.size(); ++n)
				{
					if(molecules[n].isVisible())
					{
						size_t linkcount = ingredients.getMolecules().getNumLinks(n);

						float x_draw_mono_orig = molecules[n].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
						float y_draw_mono_orig = molecules[n].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
						float z_draw_mono_orig = molecules[n].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

						for(size_t nn=0; nn < linkcount; ++nn){
							size_t neighboridx = ingredients.getMolecules().getNeighborIdx(n, nn);

							//draw only one bond
							if(neighboridx < n)
							{
								float x_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[0]+ingredients.getTranslationInX();
								float y_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[1]+ingredients.getTranslationInY();
								float z_draw_mono_nn = ingredients.getMolecules()[neighboridx].getSmoothCoordinate()[2]+ingredients.getTranslationInZ();

								glBegin(GL_LINES);						// draw bond
								glColor3f(molecules[n].getColor().getX(), molecules[n].getColor().getY(), molecules[n].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_orig, y_draw_mono_orig, z_draw_mono_orig);
								glColor3f(ingredients.getMolecules()[neighboridx].getColor().getX(), ingredients.getMolecules()[neighboridx].getColor().getY(), ingredients.getMolecules()[neighboridx].getColor().getZ());				// set the bond color
								glVertex3f(x_draw_mono_nn, y_draw_mono_nn, z_draw_mono_nn);
								glEnd();
							}
						}
					}
				}
			}
		}
	}
	else
	{ // nothing to do instead

	}
}
